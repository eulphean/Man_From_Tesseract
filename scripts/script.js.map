{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/math-ds/build/math-ds.esm.js","webpack:///./src/Agent.js","webpack:///./src/Plane.js","webpack:///./src/SparkUtility.js","webpack:///./src/Tesseract.js","webpack:///./src/World.js","webpack:///./src/main.js","webpack:///external \"Diagnostics\"","webpack:///external \"Patches\"","webpack:///external \"Reactive\"","webpack:///external \"Scene\"","webpack:///external \"Time\""],"names":["Diagnostics","require","DIRECTION","UP","DOWN","Agent","constructor","object","tesseracts","planes","sceneObject","hidden","position","SparkUtility","idx","name","split","target","getPosition","curDirection","getDirection","upVel","Vector3","downVel","diff","update","seek","syncPosition","add","subVectors","length","resetRunner","randIdx","t","p","d","transform","rotationY","Math","PI","Plane","direction","clone","Patches","Reactive","getLastPosition","posX","x","pinLastValue","posY","y","posZ","z","syncSceneObject","targetVector","syncSceneObjectWorld","worldTransform","random","min","max","isDecimal","toFixed","floor","Tesseract","startAngle","factor","World","sceneObjects","setupTesseracts","setupPlanes","agents","setupAgents","snapshot","forEach","a","objs","o","push","Scene","Time","world","Promise","all","root","findByPath","then","objects","prepareSceneObjects","log","timeInterval","setIntervalWithSnapshot","elapsedTime"],"mappings":"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;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;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A;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA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AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,aAAa,SAAS;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,aAAa,WAAW;AACxB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,WAAW;AACxB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,WAAW;AACxB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,WAAW;AACxB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB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CA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aA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","file":"script.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.js\");\n","/**\n * math-ds v1.2.1 build Fri May 01 2020\n * https://github.com/vanruesc/math-ds\n * Copyright 2020 Raoul van Rüschen\n * @license Zlib\n */\n/**\r\n * A vector with three components.\r\n */\r\n\r\nclass Vector3 {\r\n\r\n\t/**\r\n\t * Constructs a new vector.\r\n\t *\r\n\t * @param {Number} [x=0] - The X component.\r\n\t * @param {Number} [y=0] - The Y component.\r\n\t * @param {Number} [z=0] - The Z component.\r\n\t */\r\n\r\n\tconstructor(x = 0, y = 0, z = 0) {\r\n\r\n\t\t/**\r\n\t\t * The X component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\t/**\r\n\t\t * The Y component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\t/**\r\n\t\t * The Z component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.z = z;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this vector\r\n\t *\r\n\t * @param {Number} x - The X component.\r\n\t * @param {Number} y - The Y component.\r\n\t * @param {Number} z - The Z component.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tset(x, y, z) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Randomizes the values of this vector\r\n\t *\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\trandom() {\r\n\r\n\t\tthis.x = Math.random();\r\n\t\tthis.y = Math.random();\r\n\t\tthis.z = Math.random();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of another vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tcopy(v) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this vector.\r\n\t *\r\n\t * @return {Vector3} A clone of this vector.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor(this.x, this.y, this.z);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies values from an array.\r\n\t *\r\n\t * @param {Number[]} array - An array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tfromArray(array, offset = 0) {\r\n\r\n\t\tthis.x = array[offset];\r\n\t\tthis.y = array[offset + 1];\r\n\t\tthis.z = array[offset + 2];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this vector in an array.\r\n\t *\r\n\t * @param {Array} [array] - A target array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Number[]} The array.\r\n\t */\r\n\r\n\ttoArray(array = [], offset = 0) {\r\n\r\n\t\tarray[offset] = this.x;\r\n\t\tarray[offset + 1] = this.y;\r\n\t\tarray[offset + 2] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this vector based on a spherical description.\r\n\t *\r\n\t * @param {Spherical} s - A spherical description.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromSpherical(s) {\r\n\r\n\t\treturn this.setFromSphericalCoords(s.radius, s.phi, s.theta);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this vector based on spherical coordinates.\r\n\t *\r\n\t * @param {Number} radius - The radius.\r\n\t * @param {Number} phi - The polar angle.\r\n\t * @param {Number} theta - The angle around the equator of the sphere.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromSphericalCoords(radius, phi, theta) {\r\n\r\n\t\tconst sinPhiRadius = Math.sin(phi) * radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin(theta);\r\n\t\tthis.y = Math.cos(phi) * radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos(theta);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this vector based on a cylindrical description.\r\n\t *\r\n\t * @param {Cylindrical} c - A cylindrical description.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromCylindrical(c) {\r\n\r\n\t\treturn this.setFromCylindricalCoords(c.radius, c.theta, c.y);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this vector based on cylindrical coordinates.\r\n\t *\r\n\t * @param {Number} radius - The radius.\r\n\t * @param {Number} theta - Theta.\r\n\t * @param {Number} y - The height.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromCylindricalCoords(radius, theta, y) {\r\n\r\n\t\tthis.x = radius * Math.sin(theta);\r\n\t\tthis.y = y;\r\n\t\tthis.z = radius * Math.cos(theta);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a matrix column.\r\n\t *\r\n\t * @param {Matrix4} m - A 3x3 matrix.\r\n\t * @param {Number} index - A column index of the range [0, 2].\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromMatrix3Column(m, index) {\r\n\r\n\t\treturn this.fromArray(m.elements, index * 3);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a matrix column.\r\n\t *\r\n\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t * @param {Number} index - A column index of the range [0, 3].\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromMatrixColumn(m, index) {\r\n\r\n\t\treturn this.fromArray(m.elements, index * 4);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts the position from a matrix.\r\n\t *\r\n\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromMatrixPosition(m) {\r\n\r\n\t\tconst me = m.elements;\r\n\r\n\t\tthis.x = me[12];\r\n\t\tthis.y = me[13];\r\n\t\tthis.z = me[14];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts the scale from a matrix.\r\n\t *\r\n\t * @param {Matrix4} m - A 4x4 matrix.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetFromMatrixScale(m) {\r\n\r\n\t\tconst sx = this.setFromMatrixColumn(m, 0).length();\r\n\t\tconst sy = this.setFromMatrixColumn(m, 1).length();\r\n\t\tconst sz = this.setFromMatrixColumn(m, 2).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a vector to this one.\r\n\t *\r\n\t * @param {Vector3} v - The vector to add.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tadd(v) {\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a scalar to this vector.\r\n\t *\r\n\t * @param {Number} s - The scalar to add.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\taddScalar(s) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the sum of two given vectors.\r\n\t *\r\n\t * @param {Vector3} a - A vector.\r\n\t * @param {Vector3} b - Another vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\taddVectors(a, b) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a scaled vector to this one.\r\n\t *\r\n\t * @param {Vector3} v - The vector to scale and add.\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\taddScaledVector(v, s) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts a vector from this vector.\r\n\t *\r\n\t * @param {Vector3} v - The vector to subtract.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsub(v) {\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts a scalar from this vector.\r\n\t *\r\n\t * @param {Number} s - The scalar to subtract.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsubScalar(s) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the difference between two given vectors.\r\n\t *\r\n\t * @param {Vector3} a - A vector.\r\n\t * @param {Vector3} b - A second vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsubVectors(a, b) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this vector with another vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tmultiply(v) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this vector with a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tmultiplyScalar(s) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\t\tthis.z *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the product of two given vectors.\r\n\t *\r\n\t * @param {Vector3} a - A vector.\r\n\t * @param {Vector3} b - Another vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tmultiplyVectors(a, b) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Divides this vector by another vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tdivide(v) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Divides this vector by a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tdivideScalar(s) {\r\n\r\n\t\tthis.x /= s;\r\n\t\tthis.y /= s;\r\n\t\tthis.z /= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the cross product of the given vectors.\r\n\t *\r\n\t * @param {Vector3} a - A vector.\r\n\t * @param {Vector3} b - Another vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tcrossVectors(a, b) {\r\n\r\n\t\tconst ax = a.x, ay = a.y, az = a.z;\r\n\t\tconst bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the cross product of this vector and the given one.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tcross(v) {\r\n\r\n\t\treturn this.crossVectors(this, v);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a matrix to this direction vector.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\ttransformDirection(m) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a matrix to this vector.\r\n\t *\r\n\t * @param {Matrix3} m - A matrix.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tapplyMatrix3(m) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\r\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\r\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a normal matrix to this vector and normalizes it.\r\n\t *\r\n\t * @param {Matrix3} m - A normal matrix.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tapplyNormalMatrix(m) {\r\n\r\n\t\treturn this.applyMatrix3(m).normalize();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a matrix to this vector.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tapplyMatrix4(m) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12];\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13];\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a quaternion to this vector.\r\n\t *\r\n\t * @param {Quaternion} q - A quaternion.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tapplyQuaternion(q) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t// Calculate: quaternion * vector.\r\n\t\tconst ix = qw * x + qy * z - qz * y;\r\n\t\tconst iy = qw * y + qz * x - qx * z;\r\n\t\tconst iz = qw * z + qx * y - qy * x;\r\n\t\tconst iw = -qx * x - qy * y - qz * z;\r\n\r\n\t\t// Calculate: result * inverse quaternion.\r\n\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Negates this vector.\r\n\t *\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tnegate() {\r\n\r\n\t\tthis.x = -this.x;\r\n\t\tthis.y = -this.y;\r\n\t\tthis.z = -this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the dot product with another vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Number} The dot product.\r\n\t */\r\n\r\n\tdot(v) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Reflects this vector. The given plane normal is assumed to be normalized.\r\n\t *\r\n\t * @param {Vector3} n - A normal.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\treflect(n) {\r\n\r\n\t\tconst nx = n.x;\r\n\t\tconst ny = n.y;\r\n\t\tconst nz = n.z;\r\n\r\n\t\tthis.sub(n.multiplyScalar(2 * this.dot(n)));\r\n\r\n\t\t// Restore the normal.\r\n\t\tn.set(nx, ny, nz);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the angle to the given vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Number} The angle in radians.\r\n\t */\r\n\r\n\tangleTo(v) {\r\n\r\n\t\tconst denominator = Math.sqrt(this.lengthSquared() * v.lengthSquared());\r\n\r\n\t\treturn (denominator === 0.0) ? (Math.PI * 0.5) :\r\n\t\t\tMath.acos(Math.min(Math.max(this.dot(v) / denominator, -1), 1));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the Manhattan length of this vector.\r\n\t *\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tmanhattanLength() {\r\n\r\n\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared length of this vector.\r\n\t *\r\n\t * @return {Number} The squared length.\r\n\t */\r\n\r\n\tlengthSquared() {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the length of this vector.\r\n\t *\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tlength() {\r\n\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the Manhattan distance to a given vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tmanhattanDistanceTo(v) {\r\n\r\n\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared distance to a given vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Number} The squared distance.\r\n\t */\r\n\r\n\tdistanceToSquared(v) {\r\n\r\n\t\tconst dx = this.x - v.x;\r\n\t\tconst dy = this.y - v.y;\r\n\t\tconst dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance to a given vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tdistanceTo(v) {\r\n\r\n\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes this vector.\r\n\t *\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tnormalize() {\r\n\r\n\t\treturn this.divideScalar(this.length());\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the length of this vector.\r\n\t *\r\n\t * @param {Number} length - The new length.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tsetLength(length) {\r\n\r\n\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adopts the min value for each component of this vector and the given one.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tmin(v) {\r\n\r\n\t\tthis.x = Math.min(this.x, v.x);\r\n\t\tthis.y = Math.min(this.y, v.y);\r\n\t\tthis.z = Math.min(this.z, v.z);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adopts the max value for each component of this vector and the given one.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tmax(v) {\r\n\r\n\t\tthis.x = Math.max(this.x, v.x);\r\n\t\tthis.y = Math.max(this.y, v.y);\r\n\t\tthis.z = Math.max(this.z, v.z);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clamps this vector.\r\n\t *\r\n\t * @param {Vector3} min - The lower bounds. Assumed to be smaller than max.\r\n\t * @param {Vector3} max - The upper bounds. Assumed to be greater than min.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tclamp(min, max) {\r\n\r\n\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Floors this vector.\r\n\t *\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tfloor() {\r\n\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\tthis.z = Math.floor(this.z);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Ceils this vector.\r\n\t *\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tceil() {\r\n\r\n\t\tthis.x = Math.ceil(this.x);\r\n\t\tthis.y = Math.ceil(this.y);\r\n\t\tthis.z = Math.ceil(this.z);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rounds this vector.\r\n\t *\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tround() {\r\n\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\tthis.z = Math.round(this.z);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Lerps towards the given vector.\r\n\t *\r\n\t * @param {Vector3} v - The target vector.\r\n\t * @param {Number} alpha - The lerp factor.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tlerp(v, alpha) {\r\n\r\n\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\tthis.y += (v.y - this.y) * alpha;\r\n\t\tthis.z += (v.z - this.z) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the lerp result of the given vectors.\r\n\t *\r\n\t * @param {Vector3} v1 - A base vector.\r\n\t * @param {Vector3} v2 - The target vector.\r\n\t * @param {Number} alpha - The lerp factor.\r\n\t * @return {Vector3} This vector.\r\n\t */\r\n\r\n\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this vector equals the given one.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Boolean} Whether this vector equals the given one.\r\n\t */\r\n\r\n\tequals(v) {\r\n\r\n\t\treturn (v.x === this.x && v.y === this.y && v.z === this.z);\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst v = new Vector3();\r\n\r\n/**\r\n * A list of points.\r\n *\r\n * @type {Vector3[]}\r\n * @private\r\n */\r\n\r\nconst points = [\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3()\r\n];\r\n\r\n/**\r\n * A 3D box.\r\n */\r\n\r\nclass Box3 {\r\n\r\n\t/**\r\n\t * Constructs a new box.\r\n\t *\r\n\t * @param {Vector3} [min] - The lower bounds.\r\n\t * @param {Vector3} [max] - The upper bounds.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tmin = new Vector3(Infinity, Infinity, Infinity),\r\n\t\tmax = new Vector3(-Infinity, -Infinity, -Infinity)\r\n\t) {\r\n\r\n\t\t/**\r\n\t\t * The lower bounds.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.min = min;\r\n\r\n\t\t/**\r\n\t\t * The upper bounds.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this box.\r\n\t *\r\n\t * @param {Vector3} min - The lower bounds.\r\n\t * @param {Vector3} max - The upper bounds.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tset(min, max) {\r\n\r\n\t\tthis.min.copy(min);\r\n\t\tthis.max.copy(max);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a given box.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tcopy(b) {\r\n\r\n\t\tthis.min.copy(b.min);\r\n\t\tthis.max.copy(b.max);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this box.\r\n\t *\r\n\t * @return {Box3} A clone of this box.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this box empty.\r\n\t *\r\n\t * The lower bounds are set to infinity and the upper bounds to negative\r\n\t * infinity to create an infinitely small box.\r\n\t *\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tmakeEmpty() {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether this box is truly empty.\r\n\t *\r\n\t * This is a more robust check for emptiness since the volume can get positive\r\n\t * with two negative axes.\r\n\t *\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tisEmpty() {\r\n\r\n\t\treturn (\r\n\t\t\tthis.max.x < this.min.x ||\r\n\t\t\tthis.max.y < this.min.y ||\r\n\t\t\tthis.max.z < this.min.z\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the center of this box.\r\n\t *\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} A vector that describes the center of this box.\r\n\t */\r\n\r\n\tgetCenter(target = new Vector3()) {\r\n\r\n\t\treturn !this.isEmpty() ?\r\n\t\t\ttarget.addVectors(this.min, this.max).multiplyScalar(0.5) :\r\n\t\t\ttarget.set(0, 0, 0);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the size of this box.\r\n\t *\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} A vector that describes the size of this box.\r\n\t */\r\n\r\n\tgetSize(target = new Vector3()) {\r\n\r\n\t\treturn !this.isEmpty() ?\r\n\t\t\ttarget.subVectors(this.max, this.min) :\r\n\t\t\ttarget.set(0, 0, 0);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the bounding box of the given sphere.\r\n\t *\r\n\t * @param {Sphere} sphere - A sphere.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tsetFromSphere(sphere) {\r\n\r\n\t\tthis.set(sphere.center, sphere.center);\r\n\t\tthis.expandByScalar(sphere.radius);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by the given point.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\texpandByPoint(p) {\r\n\r\n\t\tthis.min.min(p);\r\n\t\tthis.max.max(p);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by the given vector.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\texpandByVector(v) {\r\n\r\n\t\tthis.min.sub(v);\r\n\t\tthis.max.add(v);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by the given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\texpandByScalar(s) {\r\n\r\n\t\tthis.min.addScalar(-s);\r\n\t\tthis.max.addScalar(s);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Defines this box by the given points.\r\n\t *\r\n\t * @param {Vector3[]} points - The points.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tsetFromPoints(points) {\r\n\r\n\t\tlet i, l;\r\n\r\n\t\tthis.min.set(0, 0, 0);\r\n\t\tthis.max.set(0, 0, 0);\r\n\r\n\t\tfor(i = 0, l = points.length; i < l; ++i) {\r\n\r\n\t\t\tthis.expandByPoint(points[i]);\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Defines this box by the given center and size.\r\n\t *\r\n\t * @param {Vector3} center - The center.\r\n\t * @param {Number} size - The size.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tsetFromCenterAndSize(center, size) {\r\n\r\n\t\tconst halfSize = v.copy(size).multiplyScalar(0.5);\r\n\r\n\t\tthis.min.copy(center).sub(halfSize);\r\n\t\tthis.max.copy(center).add(halfSize);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clamps the given point to the boundaries of this box.\r\n\t *\r\n\t * @param {Vector3} point - A point.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The clamped point.\r\n\t */\r\n\r\n\tclampPoint(point, target = new Vector3()) {\r\n\r\n\t\treturn target.copy(point).clamp(this.min, this.max);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this box to the given point.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tdistanceToPoint(p) {\r\n\r\n\t\tconst clampedPoint = v.copy(p).clamp(this.min, this.max);\r\n\r\n\t\treturn clampedPoint.sub(p).length();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies the given matrix to this box.\r\n\t *\r\n\t * @param {Matrix4} m - The matrix.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tapplyMatrix4(m) {\r\n\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\tif(!this.isEmpty()) {\r\n\r\n\t\t\tpoints[0].set(min.x, min.y, min.z).applyMatrix4(m);\r\n\t\t\tpoints[1].set(min.x, min.y, max.z).applyMatrix4(m);\r\n\t\t\tpoints[2].set(min.x, max.y, min.z).applyMatrix4(m);\r\n\t\t\tpoints[3].set(min.x, max.y, max.z).applyMatrix4(m);\r\n\t\t\tpoints[4].set(max.x, min.y, min.z).applyMatrix4(m);\r\n\t\t\tpoints[5].set(max.x, min.y, max.z).applyMatrix4(m);\r\n\t\t\tpoints[6].set(max.x, max.y, min.z).applyMatrix4(m);\r\n\t\t\tpoints[7].set(max.x, max.y, max.z).applyMatrix4(m);\r\n\r\n\t\t\tthis.setFromPoints(points);\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Translates this box.\r\n\t *\r\n\t * @param {Vector3} offset - The offset.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\ttranslate(offset) {\r\n\r\n\t\tthis.min.add(offset);\r\n\t\tthis.max.add(offset);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Intersects this box with the given one.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tintersect(b) {\r\n\r\n\t\tthis.min.max(b.min);\r\n\t\tthis.max.min(b.max);\r\n\r\n\t\t/* Ensure that if there is no overlap, the result is fully empty to prevent\r\n\t\tsubsequent intersections to erroneously return valid values. */\r\n\t\tif(this.isEmpty()) {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by combining it with the given one.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Box3} This box.\r\n\t */\r\n\r\n\tunion(b) {\r\n\r\n\t\tthis.min.min(b.min);\r\n\t\tthis.max.max(b.max);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the given point lies inside this box.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @return {Boolean} Whether this box contains the point.\r\n\t */\r\n\r\n\tcontainsPoint(p) {\r\n\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\treturn (\r\n\t\t\tp.x >= min.x &&\r\n\t\t\tp.y >= min.y &&\r\n\t\t\tp.z >= min.z &&\r\n\t\t\tp.x <= max.x &&\r\n\t\t\tp.y <= max.y &&\r\n\t\t\tp.z <= max.z\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the given box lies inside this box.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Boolean} Whether this box contains the given one.\r\n\t */\r\n\r\n\tcontainsBox(b) {\r\n\r\n\t\tconst tMin = this.min;\r\n\t\tconst tMax = this.max;\r\n\t\tconst bMin = b.min;\r\n\t\tconst bMax = b.max;\r\n\r\n\t\treturn (\r\n\t\t\ttMin.x <= bMin.x && bMax.x <= tMax.x &&\r\n\t\t\ttMin.y <= bMin.y && bMax.y <= tMax.y &&\r\n\t\t\ttMin.z <= bMin.z && bMax.z <= tMax.z\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this box intersects the given one.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Boolean} Whether the boxes intersect.\r\n\t */\r\n\r\n\tintersectsBox(b) {\r\n\r\n\t\tconst tMin = this.min;\r\n\t\tconst tMax = this.max;\r\n\t\tconst bMin = b.min;\r\n\t\tconst bMax = b.max;\r\n\r\n\t\treturn (\r\n\t\t\tbMax.x >= tMin.x &&\r\n\t\t\tbMax.y >= tMin.y &&\r\n\t\t\tbMax.z >= tMin.z &&\r\n\t\t\tbMin.x <= tMax.x &&\r\n\t\t\tbMin.y <= tMax.y &&\r\n\t\t\tbMin.z <= tMax.z\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this box intersects the given sphere.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @return {Boolean} Whether the box intersects the sphere.\r\n\t */\r\n\r\n\tintersectsSphere(s) {\r\n\r\n\t\t// Find the point in this box that is closest to the sphere's center.\r\n\t\tconst closestPoint = this.clampPoint(s.center, v);\r\n\r\n\t\t// If that point is inside the sphere, it intersects this box.\r\n\t\treturn (closestPoint.distanceToSquared(s.center) <= (s.radius * s.radius));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this box intersects the given plane.\r\n\t *\r\n\t * Computes the minimum and maximum dot product values. If those values are on\r\n\t * the same side (back or front) of the plane, then there is no intersection.\r\n\t *\r\n\t * @param {Plane} p - A plane.\r\n\t * @return {Boolean} Whether the box intersects the plane.\r\n\t */\r\n\r\n\tintersectsPlane(p) {\r\n\r\n\t\tlet min, max;\r\n\r\n\t\tif(p.normal.x > 0) {\r\n\r\n\t\t\tmin = p.normal.x * this.min.x;\r\n\t\t\tmax = p.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = p.normal.x * this.max.x;\r\n\t\t\tmax = p.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif(p.normal.y > 0) {\r\n\r\n\t\t\tmin += p.normal.y * this.min.y;\r\n\t\t\tmax += p.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += p.normal.y * this.max.y;\r\n\t\t\tmax += p.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif(p.normal.z > 0) {\r\n\r\n\t\t\tmin += p.normal.z * this.min.z;\r\n\t\t\tmax += p.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += p.normal.z * this.max.z;\r\n\t\t\tmax += p.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn (min <= -p.constant && max >= -p.constant);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this box equals the given one.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Boolean} Whether this box equals the given one.\r\n\t */\r\n\r\n\tequals(b) {\r\n\r\n\t\treturn (b.min.equals(this.min) && b.max.equals(this.max));\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A box.\r\n *\r\n * @type {Box3}\r\n * @private\r\n */\r\n\r\nconst box = new Box3();\r\n\r\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst v$1 = new Vector3();\r\n\r\n/**\r\n * A sphere.\r\n */\r\n\r\nclass Sphere {\r\n\r\n\t/**\r\n\t * Constructs a new sphere.\r\n\t *\r\n\t * @param {Vector3} [center] - The center.\r\n\t * @param {Number} [radius] - The radius.\r\n\t */\r\n\r\n\tconstructor(center = new Vector3(), radius = 0) {\r\n\r\n\t\t/**\r\n\t\t * The center.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.center = center;\r\n\r\n\t\t/**\r\n\t\t * The radius.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.radius = radius;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the center and the radius.\r\n\t *\r\n\t * @param {Vector3} center - The center.\r\n\t * @param {Number} radius - The radius.\r\n\t * @return {Sphere} This sphere.\r\n\t */\r\n\r\n\tset(center, radius) {\r\n\r\n\t\tthis.center.copy(center);\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the given sphere.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @return {Sphere} This sphere.\r\n\t */\r\n\r\n\tcopy(s) {\r\n\r\n\t\tthis.center.copy(s.center);\r\n\t\tthis.radius = s.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this sphere.\r\n\t *\r\n\t * @return {Sphere} The cloned sphere.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this sphere from points.\r\n\t *\r\n\t * @param {Vector3[]} points - The points.\r\n\t * @param {Vector3} [center] - An optional center.\r\n\t * @return {Sphere} This sphere.\r\n\t */\r\n\r\n\tsetFromPoints(points, center = box.setFromPoints(points).getCenter(this.center)) {\r\n\r\n\t\tlet maxRadiusSq = 0;\r\n\t\tlet i, l;\r\n\r\n\t\tfor(i = 0, l = points.length; i < l; ++i) {\r\n\r\n\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\r\n\r\n\t\t}\r\n\r\n\t\tthis.radius = Math.sqrt(maxRadiusSq);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the bounding sphere of the given box.\r\n\t *\r\n\t * @param {Box3} box - A box.\r\n\t * @return {Sphere} This pshere.\r\n\t */\r\n\r\n\tsetFromBox(box) {\r\n\r\n\t\tbox.getCenter(this.center);\r\n\t\tthis.radius = box.getSize(v$1).length() * 0.5;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this sphere is empty.\r\n\t *\r\n\t * @return {Boolean} Whether this sphere is empty.\r\n\t */\r\n\r\n\tisEmpty() {\r\n\r\n\t\treturn (this.radius <= 0);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Translates this sphere.\r\n\t *\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Sphere} This sphere.\r\n\t */\r\n\r\n\ttranslate(offset) {\r\n\r\n\t\tthis.center.add(offset);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clamps the given point to this sphere.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The clamped point.\r\n\t */\r\n\r\n\tclampPoint(p, target = new Vector3()) {\r\n\r\n\t\tconst deltaLengthSq = this.center.distanceToSquared(p);\r\n\r\n\t\ttarget.copy(p);\r\n\r\n\t\tif(deltaLengthSq > (this.radius * this.radius)) {\r\n\r\n\t\t\ttarget.sub(this.center).normalize();\r\n\t\t\ttarget.multiplyScalar(this.radius).add(this.center);\r\n\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this sphere to the given point.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tdistanceToPoint(p) {\r\n\r\n\t\treturn (p.distanceTo(this.center) - this.radius);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the given point lies inside this sphere.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @return {Boolean} Whether this sphere contains the point.\r\n\t */\r\n\r\n\tcontainsPoint(p) {\r\n\r\n\t\treturn (p.distanceToSquared(this.center) <= (this.radius * this.radius));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the this sphere intersects with the given one.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @return {Boolean} Whether this sphere intersects with the given one.\r\n\t */\r\n\r\n\tintersectsSphere(s) {\r\n\r\n\t\tconst radiusSum = this.radius + s.radius;\r\n\r\n\t\treturn s.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the this sphere intersects with the given box.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Boolean} Whether this sphere intersects with the given box.\r\n\t */\r\n\r\n\tintersectsBox(b) {\r\n\r\n\t\treturn b.intersectsSphere(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the this sphere intersects with the given plane.\r\n\t *\r\n\t * @param {Plane} p - A plane.\r\n\t * @return {Boolean} Whether this sphere intersects with the given plane.\r\n\t */\r\n\r\n\tintersectsPlane(p) {\r\n\r\n\t\treturn (Math.abs(p.distanceToPoint(this.center)) <= this.radius);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this sphere equals the given one.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @return {Boolean} Whether the spheres are equal.\r\n\t */\r\n\r\n\tequals(s) {\r\n\r\n\t\treturn (s.center.equals(this.center) && (s.radius === this.radius));\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector with two components.\r\n */\r\n\r\nclass Vector2 {\r\n\r\n\t/**\r\n\t * Constructs a new vector.\r\n\t *\r\n\t * @param {Number} [x=0] - The X component.\r\n\t * @param {Number} [y=0] - The Y component.\r\n\t */\r\n\r\n\tconstructor(x = 0, y = 0) {\r\n\r\n\t\t/**\r\n\t\t * The X component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\t/**\r\n\t\t * The Y component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.y = y;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * The width. This is an alias for X.\r\n\t *\r\n\t * @type {Number}\r\n\t */\r\n\r\n\tget width() {\r\n\r\n\t\treturn this.x;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the width.\r\n\t *\r\n\t * @type {Number}\r\n\t */\r\n\r\n\tset width(value) {\r\n\r\n\t\treturn this.x = value;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * The height. This is an alias for Y.\r\n\t *\r\n\t * @type {Number}\r\n\t */\r\n\r\n\tget height() {\r\n\r\n\t\treturn this.y;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the height.\r\n\t *\r\n\t * @type {Number}\r\n\t */\r\n\r\n\tset height(value) {\r\n\r\n\t\treturn this.y = value;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this vector\r\n\t *\r\n\t * @param {Number} x - The X component.\r\n\t * @param {Number} y - The Y component.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tset(x, y) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Randomizes the values of this vector\r\n\t *\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\trandom() {\r\n\r\n\t\tthis.x = Math.random();\r\n\t\tthis.y = Math.random();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of another vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tcopy(v) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this vector.\r\n\t *\r\n\t * @return {Vector2} A clone of this vector.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor(this.x, this.y);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies values from an array.\r\n\t *\r\n\t * @param {Number[]} array - An array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tfromArray(array, offset = 0) {\r\n\r\n\t\tthis.x = array[offset];\r\n\t\tthis.y = array[offset + 1];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this vector in an array.\r\n\t *\r\n\t * @param {Array} [array] - A target array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Number[]} The array.\r\n\t */\r\n\r\n\ttoArray(array = [], offset = 0) {\r\n\r\n\t\tarray[offset] = this.x;\r\n\t\tarray[offset + 1] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a vector to this one.\r\n\t *\r\n\t * @param {Vector2} v - The vector to add.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tadd(v) {\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a scalar to this vector.\r\n\t *\r\n\t * @param {Number} s - The scalar to add.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\taddScalar(s) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the sum of two given vectors.\r\n\t *\r\n\t * @param {Vector2} a - A vector.\r\n\t * @param {Vector2} b - Another vector.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\taddVectors(a, b) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a scaled vector to this one.\r\n\t *\r\n\t * @param {Vector2} v - The vector to scale and add.\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\taddScaledVector(v, s) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts a vector from this vector.\r\n\t *\r\n\t * @param {Vector2} v - The vector to subtract.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tsub(v) {\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts a scalar from this vector.\r\n\t *\r\n\t * @param {Number} s - The scalar to subtract.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tsubScalar(s) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the difference between two given vectors.\r\n\t *\r\n\t * @param {Vector2} a - A vector.\r\n\t * @param {Vector2} b - A second vector.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tsubVectors(a, b) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this vector with another vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tmultiply(v) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this vector with a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tmultiplyScalar(s) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Divides this vector by another vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tdivide(v) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Divides this vector by a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tdivideScalar(s) {\r\n\r\n\t\tthis.x /= s;\r\n\t\tthis.y /= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies the given matrix to this vector.\r\n\t *\r\n\t * @param {Matrix3} m - A matrix.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tapplyMatrix3(m) {\r\n\r\n\t\tconst x = this.x, y = this.y;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[3] * y + e[6];\r\n\t\tthis.y = e[1] * x + e[4] * y + e[7];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the dot product with another vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Number} The dot product.\r\n\t */\r\n\r\n\tdot(v) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the cross product with another vector.\r\n\t *\r\n\t * This method calculates a scalar that would result from a regular 3D cross\r\n\t * product of the input vectors, while taking their Z values implicitly as 0.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Number} The cross product.\r\n\t */\r\n\r\n\tcross(v) {\r\n\r\n\t\treturn this.x * v.y - this.y * v.x;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the Manhattan length of this vector.\r\n\t *\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tmanhattanLength() {\r\n\r\n\t\treturn Math.abs(this.x) + Math.abs(this.y);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared length of this vector.\r\n\t *\r\n\t * @return {Number} The squared length.\r\n\t */\r\n\r\n\tlengthSquared() {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the length of this vector.\r\n\t *\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tlength() {\r\n\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the Manhattan distance to a given vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Number} The squared distance.\r\n\t */\r\n\r\n\tmanhattanDistanceTo(v) {\r\n\r\n\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared distance to a given vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Number} The squared distance.\r\n\t */\r\n\r\n\tdistanceToSquared(v) {\r\n\r\n\t\tconst dx = this.x - v.x;\r\n\t\tconst dy = this.y - v.y;\r\n\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance to a given vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tdistanceTo(v) {\r\n\r\n\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes this vector.\r\n\t *\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tnormalize() {\r\n\r\n\t\treturn this.divideScalar(this.length());\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the length of this vector.\r\n\t *\r\n\t * @param {Number} length - The new length.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tsetLength(length) {\r\n\r\n\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adopts the min value for each component of this vector and the given one.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tmin(v) {\r\n\r\n\t\tthis.x = Math.min(this.x, v.x);\r\n\t\tthis.y = Math.min(this.y, v.y);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * adopts the max value for each component of this vector and the given one.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tmax(v) {\r\n\r\n\t\tthis.x = Math.max(this.x, v.x);\r\n\t\tthis.y = Math.max(this.y, v.y);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clamps this vector.\r\n\t *\r\n\t * @param {Vector2} min - A vector, assumed to be smaller than max.\r\n\t * @param {Vector2} max - A vector, assumed to be greater than min.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tclamp(min, max) {\r\n\r\n\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Floors this vector.\r\n\t *\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tfloor() {\r\n\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Ceils this vector.\r\n\t *\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tceil() {\r\n\r\n\t\tthis.x = Math.ceil(this.x);\r\n\t\tthis.y = Math.ceil(this.y);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rounds this vector.\r\n\t *\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tround() {\r\n\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Negates this vector.\r\n\t *\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tnegate() {\r\n\r\n\t\tthis.x = -this.x;\r\n\t\tthis.y = -this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the angle in radians with respect to the positive X-axis.\r\n\t *\r\n\t * @return {Number} The angle.\r\n\t */\r\n\r\n\tangle() {\r\n\r\n\t\treturn Math.atan2(-this.y, -this.x) + Math.PI;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Lerps towards the given vector.\r\n\t *\r\n\t * @param {Vector2} v - The target vector.\r\n\t * @param {Number} alpha - The lerp factor.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tlerp(v, alpha) {\r\n\r\n\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\tthis.y += (v.y - this.y) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the lerp result of the given vectors.\r\n\t *\r\n\t * @param {Vector2} v1 - A base vector.\r\n\t * @param {Vector2} v2 - The target vector.\r\n\t * @param {Number} alpha - The lerp factor.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates this vector around a given center.\r\n\t *\r\n\t * @param {Vector2} center - The center.\r\n\t * @param {Number} angle - The rotation in radians.\r\n\t * @return {Vector2} This vector.\r\n\t */\r\n\r\n\trotateAround(center, angle) {\r\n\r\n\t\tconst c = Math.cos(angle), s = Math.sin(angle);\r\n\r\n\t\tconst x = this.x - center.x;\r\n\t\tconst y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this vector equals the given one.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Boolean} Whether this vector equals the given one.\r\n\t */\r\n\r\n\tequals(v) {\r\n\r\n\t\treturn (v.x === this.x && v.y === this.y);\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector.\r\n *\r\n * @type {Vector2}\r\n * @private\r\n */\r\n\r\nconst v$2 = new Vector2();\r\n\r\n/**\r\n * A 2D box.\r\n */\r\n\r\nclass Box2 {\r\n\r\n\t/**\r\n\t * Constructs a new box.\r\n\t *\r\n\t * @param {Vector2} [min] - The lower bounds.\r\n\t * @param {Vector2} [max] - The upper bounds.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tmin = new Vector2(Infinity, Infinity),\r\n\t\tmax = new Vector2(-Infinity, -Infinity)\r\n\t) {\r\n\r\n\t\t/**\r\n\t\t * The lower bounds.\r\n\t\t *\r\n\t\t * @type {Vector2}\r\n\t\t */\r\n\r\n\t\tthis.min = min;\r\n\r\n\t\t/**\r\n\t\t * The upper bounds.\r\n\t\t *\r\n\t\t * @type {Vector2}\r\n\t\t */\r\n\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this box.\r\n\t *\r\n\t * @param {Vector2} min - The lower bounds.\r\n\t * @param {Vector2} max - The upper bounds.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tset(min, max) {\r\n\r\n\t\tthis.min.copy(min);\r\n\t\tthis.max.copy(max);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a given box.\r\n\t *\r\n\t * @param {Box2} b - A box.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tcopy(b) {\r\n\r\n\t\tthis.min.copy(b.min);\r\n\t\tthis.max.copy(b.max);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this box.\r\n\t *\r\n\t * @return {Box2} A clone of this box.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this box empty.\r\n\t *\r\n\t * The lower bounds are set to infinity and the upper bounds to negative\r\n\t * infinity to create an infinitely small box.\r\n\t *\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tmakeEmpty() {\r\n\r\n\t\tthis.min.x = this.min.y = Infinity;\r\n\t\tthis.max.x = this.max.y = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether this box is truly empty.\r\n\t *\r\n\t * This is a more robust check for emptiness since the volume can get positive\r\n\t * with two negative axes.\r\n\t *\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tisEmpty() {\r\n\r\n\t\treturn (\r\n\t\t\tthis.max.x < this.min.x ||\r\n\t\t\tthis.max.y < this.min.y\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the center of this box.\r\n\t *\r\n\t * @param {Vector2} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector2} A vector that describes the center of this box.\r\n\t */\r\n\r\n\tgetCenter(target = new Vector2()) {\r\n\r\n\t\treturn !this.isEmpty() ?\r\n\t\t\ttarget.addVectors(this.min, this.max).multiplyScalar(0.5) :\r\n\t\t\ttarget.set(0, 0);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the size of this box.\r\n\t *\r\n\t * @param {Vector2} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector2} A vector that describes the size of this box.\r\n\t */\r\n\r\n\tgetSize(target = new Vector2()) {\r\n\r\n\t\treturn !this.isEmpty() ?\r\n\t\t\ttarget.subVectors(this.max, this.min) :\r\n\t\t\ttarget.set(0, 0);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the bounding sphere of this box.\r\n\t *\r\n\t * @param {Sphere} [target] - A target sphere. If none is provided, a new one will be created.\r\n\t * @return {Sphere} The bounding sphere of this box.\r\n\t */\r\n\r\n\tgetBoundingSphere(target = new Sphere()) {\r\n\r\n\t\tthis.getCenter(target.center);\r\n\r\n\t\ttarget.radius = this.getSize(v$2).length() * 0.5;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by the given point.\r\n\t *\r\n\t * @param {Vector2} p - A point.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\texpandByPoint(p) {\r\n\r\n\t\tthis.min.min(p);\r\n\t\tthis.max.max(p);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by the given vector.\r\n\t *\r\n\t * @param {Vector2} v - A vector.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\texpandByVector(v) {\r\n\r\n\t\tthis.min.sub(v);\r\n\t\tthis.max.add(v);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by the given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\texpandByScalar(s) {\r\n\r\n\t\tthis.min.addScalar(-s);\r\n\t\tthis.max.addScalar(s);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Defines this box by the given points.\r\n\t *\r\n\t * @param {Vector2[]} points - The points.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tsetFromPoints(points) {\r\n\r\n\t\tlet i, l;\r\n\r\n\t\tthis.min.set(0, 0);\r\n\t\tthis.max.set(0, 0);\r\n\r\n\t\tfor(i = 0, l = points.length; i < l; ++i) {\r\n\r\n\t\t\tthis.expandByPoint(points[i]);\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Defines this box by the given center and size.\r\n\t *\r\n\t * @param {Vector2} center - The center.\r\n\t * @param {Number} size - The size.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tsetFromCenterAndSize(center, size) {\r\n\r\n\t\tconst halfSize = v$2.copy(size).multiplyScalar(0.5);\r\n\r\n\t\tthis.min.copy(center).sub(halfSize);\r\n\t\tthis.max.copy(center).add(halfSize);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clamps the given point to the boundaries of this box.\r\n\t *\r\n\t * @param {Vector2} point - A point.\r\n\t * @param {Vector2} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector2} The clamped point.\r\n\t */\r\n\r\n\tclampPoint(point, target = new Vector2()) {\r\n\r\n\t\treturn target.copy(point).clamp(this.min, this.max);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this box to the given point.\r\n\t *\r\n\t * @param {Vector2} p - A point.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tdistanceToPoint(p) {\r\n\r\n\t\tconst clampedPoint = v$2.copy(p).clamp(this.min, this.max);\r\n\r\n\t\treturn clampedPoint.sub(p).length();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Translates this box.\r\n\t *\r\n\t * @param {Vector2} offset - The offset.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\ttranslate(offset) {\r\n\r\n\t\tthis.min.add(offset);\r\n\t\tthis.max.add(offset);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Intersects this box with the given one.\r\n\t *\r\n\t * @param {Box2} b - A box.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tintersect(b) {\r\n\r\n\t\tthis.min.max(b.min);\r\n\t\tthis.max.min(b.max);\r\n\r\n\t\t/* Ensure that if there is no overlap, the result is fully empty to prevent\r\n\t\tsubsequent intersections to erroneously return valid values. */\r\n\t\tif(this.isEmpty()) {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Expands this box by combining it with the given one.\r\n\t *\r\n\t * @param {Box2} b - A box.\r\n\t * @return {Box2} This box.\r\n\t */\r\n\r\n\tunion(b) {\r\n\r\n\t\tthis.min.min(b.min);\r\n\t\tthis.max.max(b.max);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the given point lies inside this box.\r\n\t *\r\n\t * @param {Vector2} p - A point.\r\n\t * @return {Boolean} Whether this box contains the point.\r\n\t */\r\n\r\n\tcontainsPoint(p) {\r\n\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\treturn (\r\n\t\t\tp.x >= min.x &&\r\n\t\t\tp.y >= min.y &&\r\n\t\t\tp.x <= max.x &&\r\n\t\t\tp.y <= max.y\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the given box lies inside this box.\r\n\t *\r\n\t * @param {Box2} b - A box.\r\n\t * @return {Boolean} Whether this box contains the given one.\r\n\t */\r\n\r\n\tcontainsBox(b) {\r\n\r\n\t\tconst tMin = this.min;\r\n\t\tconst tMax = this.max;\r\n\t\tconst bMin = b.min;\r\n\t\tconst bMax = b.max;\r\n\r\n\t\treturn (\r\n\t\t\ttMin.x <= bMin.x && bMax.x <= tMax.x &&\r\n\t\t\ttMin.y <= bMin.y && bMax.y <= tMax.y\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this box intersects the given one.\r\n\t *\r\n\t * @param {Box2} b - A box.\r\n\t * @return {Boolean} Whether the boxes intersect.\r\n\t */\r\n\r\n\tintersectsBox(b) {\r\n\r\n\t\tconst tMin = this.min;\r\n\t\tconst tMax = this.max;\r\n\t\tconst bMin = b.min;\r\n\t\tconst bMax = b.max;\r\n\r\n\t\treturn (\r\n\t\t\tbMax.x >= tMin.x &&\r\n\t\t\tbMax.y >= tMin.y &&\r\n\t\t\tbMin.x <= tMax.x &&\r\n\t\t\tbMin.y <= tMax.y\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this box equals the given one.\r\n\t *\r\n\t * @param {Box2} b - A box.\r\n\t * @return {Boolean} Whether this box equals the given one.\r\n\t */\r\n\r\n\tequals(b) {\r\n\r\n\t\treturn (b.min.equals(this.min) && b.max.equals(this.max));\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A cylindrical coordinate system.\r\n *\r\n * For details see: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\r\n */\r\n\r\nclass Cylindrical {\r\n\r\n\t/**\r\n\t * Constructs a new cylindrical system.\r\n\t *\r\n\t * @param {Number} [radius=1] - The radius of the cylinder.\r\n\t * @param {Number} [theta=0] - Theta.\r\n\t * @param {Number} [y=0] - The height.\r\n\t */\r\n\r\n\tconstructor(radius = 1, theta = 0, y = 0) {\r\n\r\n\t\t/**\r\n\t\t * The distance from the origin to a point in the XZ-plane.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.radius = radius;\r\n\r\n\t\t/**\r\n\t\t * The counterclockwise angle in the XZ-plane measured in radians from the\r\n\t\t * positive Z-axis.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.theta = theta;\r\n\r\n\t\t/**\r\n\t\t * The height above the XZ-plane.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.y = y;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this cylindrical system.\r\n\t *\r\n\t * @param {Number} radius - The radius.\r\n\t * @param {Number} theta - Theta.\r\n\t * @param {Number} y - The height.\r\n\t * @return {Cylindrical} This cylindrical system.\r\n\t */\r\n\r\n\tset(radius, theta, y) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.theta = theta;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of the given cylindrical system.\r\n\t *\r\n\t * @param {Cylindrical} c - A cylindrical system.\r\n\t * @return {Cylindrical} This cylindrical system.\r\n\t */\r\n\r\n\tcopy(c) {\r\n\r\n\t\tthis.radius = c.radius;\r\n\t\tthis.theta = c.theta;\r\n\t\tthis.y = c.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this cylindrical system.\r\n\t *\r\n\t * @return {Cylindrical} The cloned cylindrical system.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this cylindrical system.\r\n\t *\r\n\t * @param {Vector3} v - A vector.\r\n\t * @return {Cylindrical} This cylindrical system.\r\n\t */\r\n\r\n\tsetFromVector3(v) {\r\n\r\n\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this cylindrical system based on cartesian coordinates.\r\n\t *\r\n\t * @param {Number} x - The X coordinate.\r\n\t * @param {Number} y - The Y coordinate.\r\n\t * @param {Number} z - The Z coordinate.\r\n\t * @return {Cylindrical} This cylindrical system.\r\n\t */\r\n\r\n\tsetFromCartesianCoords(x, y, z) {\r\n\r\n\t\tthis.radius = Math.sqrt(x * x + z * z);\r\n\t\tthis.theta = Math.atan2(x, z);\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A 3x3 matrix.\r\n */\r\n\r\nclass Matrix3 {\r\n\r\n\t/**\r\n\t * Constructs a new matrix.\r\n\t */\r\n\r\n\tconstructor() {\r\n\r\n\t\t/**\r\n\t\t * The matrix elements.\r\n\t\t *\r\n\t\t * @type {Float32Array}\r\n\t\t */\r\n\r\n\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t]);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this matrix.\r\n\t *\r\n\t * @param {Number} m00 - The value of the first row, first column.\r\n\t * @param {Number} m01 - The value of the first row, second column.\r\n\t * @param {Number} m02 - The value of the first row, third column.\r\n\t * @param {Number} m10 - The value of the second row, first column.\r\n\t * @param {Number} m11 - The value of the second row, second column.\r\n\t * @param {Number} m12 - The value of the second row, third column.\r\n\t * @param {Number} m20 - The value of the third row, first column.\r\n\t * @param {Number} m21 - The value of the third row, second column.\r\n\t * @param {Number} m22 - The value of the third row, third column.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tset(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] = m00; te[3] = m01; te[6] = m02;\r\n\t\tte[1] = m10; te[4] = m11; te[7] = m12;\r\n\t\tte[2] = m20; te[5] = m21; te[8] = m22;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this matrix to the identity matrix.\r\n\t *\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tidentity() {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a given matrix.\r\n\t *\r\n\t * @param {Matrix3} matrix - A matrix.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tcopy(matrix) {\r\n\r\n\t\tconst me = matrix.elements;\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] = me[0]; te[1] = me[1]; te[2] = me[2];\r\n\t\tte[3] = me[3]; te[4] = me[4]; te[5] = me[5];\r\n\t\tte[6] = me[6]; te[7] = me[7]; te[8] = me[8];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this matrix.\r\n\t *\r\n\t * @return {Matrix3} A clone of this matrix.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().fromArray(this.elements);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a given array.\r\n\t *\r\n\t * @param {Number[]} array - An array.\r\n\t * @param {Number} [offset=0] - An offset into the array.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tfromArray(array, offset = 0) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 9; ++i) {\r\n\r\n\t\t\tte[i] = array[i + offset];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this matrix in an array.\r\n\t *\r\n\t * @param {Number[]} [array] - A target array.\r\n\t * @param {Number} [offset=0] - An offset into the array.\r\n\t * @return {Number[]} The array.\r\n\t */\r\n\r\n\ttoArray(array = [], offset = 0) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 9; ++i) {\r\n\r\n\t\t\tarray[i + offset] = te[i];\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this matrix to the product of the given matrices.\r\n\t *\r\n\t * @param {Matrix3} a - A matrix.\r\n\t * @param {Matrix3} b - A matrix.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tmultiplyMatrices(a, b) {\r\n\r\n\t\tconst ae = a.elements;\r\n\t\tconst be = b.elements;\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst a11 = ae[0], a12 = ae[3], a13 = ae[6];\r\n\t\tconst a21 = ae[1], a22 = ae[4], a23 = ae[7];\r\n\t\tconst a31 = ae[2], a32 = ae[5], a33 = ae[8];\r\n\r\n\t\tconst b11 = be[0], b12 = be[3], b13 = be[6];\r\n\t\tconst b21 = be[1], b22 = be[4], b23 = be[7];\r\n\t\tconst b31 = be[2], b32 = be[5], b33 = be[8];\r\n\r\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this matrix with a given one.\r\n\t *\r\n\t * @param {Matrix3} m - A matrix.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tmultiply(m) {\r\n\r\n\t\treturn this.multiplyMatrices(this, m);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies a given matrix with this one.\r\n\t *\r\n\t * @param {Matrix3} m - A matrix.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tpremultiply(m) {\r\n\r\n\t\treturn this.multiplyMatrices(m, this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this matrix with a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tmultiplyScalar(s) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] *= s; te[3] *= s; te[6] *= s;\r\n\t\tte[1] *= s; te[4] *= s; te[7] *= s;\r\n\t\tte[2] *= s; te[5] *= s; te[8] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the determinant of this matrix.\r\n\t *\r\n\t * @return {Number} The determinant.\r\n\t */\r\n\r\n\tdeterminant() {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst a = te[0], b = te[1], c = te[2];\r\n\t\tconst d = te[3], e = te[4], f = te[5];\r\n\t\tconst g = te[6], h = te[7], i = te[8];\r\n\r\n\t\treturn (\r\n\r\n\t\t\ta * e * i -\r\n\t\t\ta * f * h -\r\n\t\t\tb * d * i +\r\n\t\t\tb * f * g +\r\n\t\t\tc * d * h -\r\n\t\t\tc * e * g\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Inverts the given matrix and stores the result in this matrix.\r\n\t *\r\n\t * @param {Matrix3} matrix - The matrix that should be inverted.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tgetInverse(matrix) {\r\n\r\n\t\tconst me = matrix.elements;\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst n11 = me[0], n21 = me[1], n31 = me[2];\r\n\t\tconst n12 = me[3], n22 = me[4], n32 = me[5];\r\n\t\tconst n13 = me[6], n23 = me[7], n33 = me[8];\r\n\r\n\t\tconst t11 = n33 * n22 - n32 * n23;\r\n\t\tconst t12 = n32 * n13 - n33 * n12;\r\n\t\tconst t13 = n23 * n12 - n22 * n13;\r\n\r\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tlet invDet;\r\n\r\n\t\tif(det !== 0) {\r\n\r\n\t\t\tinvDet = 1.0 / det;\r\n\r\n\t\t\tte[0] = t11 * invDet;\r\n\t\t\tte[1] = (n31 * n23 - n33 * n21) * invDet;\r\n\t\t\tte[2] = (n32 * n21 - n31 * n22) * invDet;\r\n\r\n\t\t\tte[3] = t12 * invDet;\r\n\t\t\tte[4] = (n33 * n11 - n31 * n13) * invDet;\r\n\t\t\tte[5] = (n31 * n12 - n32 * n11) * invDet;\r\n\r\n\t\t\tte[6] = t13 * invDet;\r\n\t\t\tte[7] = (n21 * n13 - n23 * n11) * invDet;\r\n\t\t\tte[8] = (n22 * n11 - n21 * n12) * invDet;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Transposes this matrix.\r\n\t *\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\ttranspose() {\r\n\r\n\t\tconst me = this.elements;\r\n\r\n\t\tlet t;\r\n\r\n\t\tt = me[1]; me[1] = me[3]; me[3] = t;\r\n\t\tt = me[2]; me[2] = me[6]; me[6] = t;\r\n\t\tt = me[5]; me[5] = me[7]; me[7] = t;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Scales this matrix.\r\n\t *\r\n\t * @param {Number} sx - The X scale.\r\n\t * @param {Number} sy - The Y scale.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\tscale(sx, sy) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] *= sx; te[3] *= sx; te[6] *= sx;\r\n\t\tte[1] *= sy; te[4] *= sy; te[7] *= sy;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates this matrix.\r\n\t *\r\n\t * @param {Number} theta - The rotation.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\trotate(theta) {\r\n\r\n\t\tconst c = Math.cos(theta);\r\n\t\tconst s = Math.sin(theta);\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst a11 = te[0], a12 = te[3], a13 = te[6];\r\n\t\tconst a21 = te[1], a22 = te[4], a23 = te[7];\r\n\r\n\t\tte[0] = c * a11 + s * a21;\r\n\t\tte[3] = c * a12 + s * a22;\r\n\t\tte[6] = c * a13 + s * a23;\r\n\r\n\t\tte[1] = -s * a11 + c * a21;\r\n\t\tte[4] = -s * a12 + c * a22;\r\n\t\tte[7] = -s * a13 + c * a23;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Translates this matrix.\r\n\t *\r\n\t * @param {Number} tx - The X offset.\r\n\t * @param {Number} ty - The Y offset.\r\n\t * @return {Matrix3} This matrix.\r\n\t */\r\n\r\n\ttranslate(tx, ty) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] += tx * te[2]; te[3] += tx * te[5]; te[6] += tx * te[8];\r\n\t\tte[1] += ty * te[2]; te[4] += ty * te[5]; te[7] += ty * te[8];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this matrix equals the given one.\r\n\t *\r\n\t * @param {Matrix3} m - A matrix.\r\n\t * @return {Boolean} Whether the matrix are equal.\r\n\t */\r\n\r\n\tequals(m) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tlet result = true;\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; result && i < 9; ++i) {\r\n\r\n\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\tresult = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * An enumeration of Euler rotation orders.\r\n *\r\n * @type {Object}\r\n * @property {String} XYZ - X -> Y -> Z.\r\n * @property {String} YZX - Y -> Z -> X.\r\n * @property {String} ZXY - Z -> X -> Y.\r\n * @property {String} XZY - X -> Z -> Y.\r\n * @property {String} YXZ - Y -> X -> Z.\r\n * @property {String} ZYX - Z -> Y -> X.\r\n */\r\n\r\nconst RotationOrder = {\r\n\r\n\tXYZ: \"XYZ\",\r\n\tYZX: \"YZX\",\r\n\tZXY: \"ZXY\",\r\n\tXZY: \"XZY\",\r\n\tYXZ: \"YXZ\",\r\n\tZYX: \"ZYX\"\r\n\r\n};\n\n/**\r\n * A quaternion.\r\n */\r\n\r\nclass Quaternion {\r\n\r\n\t/**\r\n\t * Constructs a new quaternion.\r\n\t *\r\n\t * @param {Number} [x=0] - The X component.\r\n\t * @param {Number} [y=0] - The Y component.\r\n\t * @param {Number} [z=0] - The Z component.\r\n\t * @param {Number} [w=0] - The W component.\r\n\t */\r\n\r\n\tconstructor(x = 0, y = 0, z = 0, w = 0) {\r\n\r\n\t\t/**\r\n\t\t * The X component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\t/**\r\n\t\t * The Y component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\t/**\r\n\t\t * The Z component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\t/**\r\n\t\t * The W component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.w = w;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the components of this quaternion.\r\n\t *\r\n\t * @param {Number} x - The X component.\r\n\t * @param {Number} y - The Y component.\r\n\t * @param {Number} z - The Z component.\r\n\t * @param {Number} w - The W component.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tset(x, y, z, w) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the components of the given quaternion.\r\n\t *\r\n\t * @param {Quaternion} q - The quaternion.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tcopy(q) {\r\n\r\n\t\tthis.x = q.x;\r\n\t\tthis.y = q.y;\r\n\t\tthis.z = q.z;\r\n\t\tthis.w = q.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this quaternion.\r\n\t *\r\n\t * @return {Quaternion} The cloned quaternion.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies values from an array.\r\n\t *\r\n\t * @param {Number[]} array - An array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tfromArray(array, offset = 0) {\r\n\r\n\t\tthis.x = array[offset];\r\n\t\tthis.y = array[offset + 1];\r\n\t\tthis.z = array[offset + 2];\r\n\t\tthis.w = array[offset + 3];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this quaternion in an array.\r\n\t *\r\n\t * @param {Array} [array] - A target array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Number[]} The array.\r\n\t */\r\n\r\n\ttoArray(array = [], offset = 0) {\r\n\r\n\t\tarray[offset] = this.x;\r\n\t\tarray[offset + 1] = this.y;\r\n\t\tarray[offset + 2] = this.z;\r\n\t\tarray[offset + 3] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the components of this quaternion based on the given Euler angles.\r\n\t *\r\n\t * For more details see: https://goo.gl/XRD1kr\r\n\t *\r\n\t * @param {Euler} euler - The euler angles.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tsetFromEuler(euler) {\r\n\r\n\t\tconst x = euler.x;\r\n\t\tconst y = euler.y;\r\n\t\tconst z = euler.z;\r\n\r\n\t\tconst cos = Math.cos;\r\n\t\tconst sin = Math.sin;\r\n\r\n\t\tconst c1 = cos(x / 2);\r\n\t\tconst c2 = cos(y / 2);\r\n\t\tconst c3 = cos(z / 2);\r\n\r\n\t\tconst s1 = sin(x / 2);\r\n\t\tconst s2 = sin(y / 2);\r\n\t\tconst s3 = sin(z / 2);\r\n\r\n\t\tswitch(euler.order) {\r\n\r\n\t\t\tcase RotationOrder.XYZ:\r\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase RotationOrder.YXZ:\r\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase RotationOrder.ZXY:\r\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase RotationOrder.ZYX:\r\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase RotationOrder.YZX:\r\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase RotationOrder.XZY:\r\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the components of this quaternion based on a given axis angle.\r\n\t *\r\n\t * For more information see:\r\n\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t *\r\n\t * @param {Vector3} axis - The axis. Assumed to be normalized.\r\n\t * @param {Number} angle - The angle in radians.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tsetFromAxisAngle(axis, angle) {\r\n\r\n\t\tconst halfAngle = angle / 2.0;\r\n\t\tconst s = Math.sin(halfAngle);\r\n\r\n\t\tthis.x = axis.x * s;\r\n\t\tthis.y = axis.y * s;\r\n\t\tthis.z = axis.z * s;\r\n\t\tthis.w = Math.cos(halfAngle);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the components of this quaternion based on a given rotation matrix.\r\n\t *\r\n\t * For more information see:\r\n\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\t *\r\n\t * @param {Matrix4} m - The rotation matrix. The upper 3x3 is assumed to be a pure rotation matrix (i.e. unscaled).\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tsetFromRotationMatrix(m) {\r\n\r\n\t\tconst te = m.elements;\r\n\r\n\t\tconst m00 = te[0], m01 = te[4], m02 = te[8];\r\n\t\tconst m10 = te[1], m11 = te[5], m12 = te[9];\r\n\t\tconst m20 = te[2], m21 = te[6], m22 = te[10];\r\n\r\n\t\tconst trace = m00 + m11 + m22;\r\n\r\n\t\tlet s;\r\n\r\n\t\tif(trace > 0) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt(trace + 1.0);\r\n\r\n\t\t\tthis.w = 0.25 / s;\r\n\t\t\tthis.x = (m21 - m12) * s;\r\n\t\t\tthis.y = (m02 - m20) * s;\r\n\t\t\tthis.z = (m10 - m01) * s;\r\n\r\n\t\t} else if(m00 > m11 && m00 > m22) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);\r\n\r\n\t\t\tthis.w = (m21 - m12) / s;\r\n\t\t\tthis.x = 0.25 * s;\r\n\t\t\tthis.y = (m01 + m10) / s;\r\n\t\t\tthis.z = (m02 + m20) / s;\r\n\r\n\t\t} else if(m11 > m22) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);\r\n\r\n\t\t\tthis.w = (m02 - m20) / s;\r\n\t\t\tthis.x = (m01 + m10) / s;\r\n\t\t\tthis.y = 0.25 * s;\r\n\t\t\tthis.z = (m12 + m21) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);\r\n\r\n\t\t\tthis.w = (m10 - m01) / s;\r\n\t\t\tthis.x = (m02 + m20) / s;\r\n\t\t\tthis.y = (m12 + m21) / s;\r\n\t\t\tthis.z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the components of this quaternion based on unit vectors.\r\n\t *\r\n\t * @param {Vector3} vFrom - A unit vector. Assumed to be normalized.\r\n\t * @param {Vector3} vTo - A unit vector. Assumed to be normalized.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tsetFromUnitVectors(vFrom, vTo) {\r\n\r\n\t\tlet r = vFrom.dot(vTo) + 1;\r\n\r\n\t\tif(r < 1e-6) {\r\n\r\n\t\t\tr = 0;\r\n\r\n\t\t\tif(Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\r\n\r\n\t\t\t\tthis.x = -vFrom.y;\r\n\t\t\t\tthis.y = vFrom.x;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = r;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = -vFrom.z;\r\n\t\t\t\tthis.z = vFrom.y;\r\n\t\t\t\tthis.w = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// crossVectors(vFrom, vTo)\r\n\t\t\tthis.x = vFrom.y * vTo.z - vFrom.z * vTo.y;\r\n\t\t\tthis.y = vFrom.z * vTo.x - vFrom.x * vTo.z;\r\n\t\t\tthis.z = vFrom.x * vTo.y - vFrom.y * vTo.x;\r\n\t\t\tthis.w = r;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the angle to another quaternion.\r\n\t *\r\n\t * @param {Quaternion} q - A quaternion.\r\n\t * @return {Number} The angle in radians.\r\n\t */\r\n\r\n\tangleTo(q) {\r\n\r\n\t\treturn 2.0 * Math.acos(Math.abs(Math.min(Math.max(this.dot(q), -1.0), 1.0)));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates this quaternion towards the given one by a given step size.\r\n\t *\r\n\t * @param {Quaternion} q - The target quaternion.\r\n\t * @param {Number} step - The step size.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\trotateTowards(q, step) {\r\n\r\n\t\tconst angle = this.angleTo(q);\r\n\r\n\t\tif(angle !== 0.0) {\r\n\r\n\t\t\tthis.slerp(q, Math.min(1.0, step / angle));\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Inverts this quaternion. The quaternion is assumed to have unit length.\r\n\t *\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tinvert() {\r\n\r\n\t\treturn this.conjugate();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Conjugates this quaternion.\r\n\t *\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tconjugate() {\r\n\r\n\t\tthis.x *= -1;\r\n\t\tthis.y *= -1;\r\n\t\tthis.z *= -1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared length of this quaternion.\r\n\t *\r\n\t * @return {Number} The squared length.\r\n\t */\r\n\r\n\tlengthSquared() {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the length of this quaternion.\r\n\t *\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tlength() {\r\n\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes this quaternion.\r\n\t *\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tnormalize() {\r\n\r\n\t\tconst l = this.length();\r\n\r\n\t\tlet invLength;\r\n\r\n\t\tif(l === 0) {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinvLength = 1.0 / l;\r\n\r\n\t\t\tthis.x = this.x * invLength;\r\n\t\t\tthis.y = this.y * invLength;\r\n\t\t\tthis.z = this.z * invLength;\r\n\t\t\tthis.w = this.w * invLength;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the dot product with a given vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Number} The dot product.\r\n\t */\r\n\r\n\tdot(v) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies the given quaternions and stores the result in this quaternion.\r\n\t *\r\n\t * For more details see:\r\n\t *  http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\t *\r\n\t * @param {Quaternion} a - A quaternion.\r\n\t * @param {Quaternion} b - Another quaternion.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tmultiplyQuaternions(a, b) {\r\n\r\n\t\tconst qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\r\n\t\tconst qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\r\n\r\n\t\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this quaternion with the given one and stores the result in\r\n\t * this quaternion.\r\n\t *\r\n\t * @param {Quaternion} q - A quaternion.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tmultiply(q) {\r\n\r\n\t\treturn this.multiplyQuaternions(this, q);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies the given quaternion with this one and stores the result in\r\n\t * this quaternion.\r\n\t *\r\n\t * @param {Quaternion} q - A quaternion.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tpremultiply(q) {\r\n\r\n\t\treturn this.multiplyQuaternions(q, this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs a spherical linear interpolation towards the given quaternion.\r\n\t *\r\n\t * For more details see:\r\n\t *  http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\t *\r\n\t * @param {Quaternion} q - A quaternion.\r\n\t * @param {Number} t - The slerp factor.\r\n\t * @return {Quaternion} This quaternion.\r\n\t */\r\n\r\n\tslerp(q, t) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\r\n\r\n\t\tlet cosHalfTheta, sinHalfThetaSquared, sinHalfTheta, halfTheta;\r\n\t\tlet s, ratioA, ratioB;\r\n\r\n\t\tif(t === 1) {\r\n\r\n\t\t\tthis.copy(q);\r\n\r\n\t\t} else if(t > 0) {\r\n\r\n\t\t\tcosHalfTheta = w * q.w + x * q.x + y * q.y + z * q.z;\r\n\r\n\t\t\tif(cosHalfTheta < 0.0) {\r\n\r\n\t\t\t\tthis.w = -q.w;\r\n\t\t\t\tthis.x = -q.x;\r\n\t\t\t\tthis.y = -q.y;\r\n\t\t\t\tthis.z = -q.z;\r\n\r\n\t\t\t\tcosHalfTheta = -cosHalfTheta;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.copy(q);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(cosHalfTheta >= 1.0) {\r\n\r\n\t\t\t\tthis.w = w;\r\n\t\t\t\tthis.x = x;\r\n\t\t\t\tthis.y = y;\r\n\t\t\t\tthis.z = z;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsinHalfThetaSquared = 1.0 - cosHalfTheta * cosHalfTheta;\r\n\t\t\t\ts = 1.0 - t;\r\n\r\n\t\t\t\tif(sinHalfThetaSquared <= Number.EPSILON) {\r\n\r\n\t\t\t\t\tthis.w = s * w + t * this.w;\r\n\t\t\t\t\tthis.x = s * x + t * this.x;\r\n\t\t\t\t\tthis.y = s * y + t * this.y;\r\n\t\t\t\t\tthis.z = s * z + t * this.z;\r\n\r\n\t\t\t\t\tthis.normalize();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsinHalfTheta = Math.sqrt(sinHalfThetaSquared);\r\n\t\t\t\t\thalfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\r\n\t\t\t\t\tratioA = Math.sin(s * halfTheta) / sinHalfTheta;\r\n\t\t\t\t\tratioB = Math.sin(t * halfTheta) / sinHalfTheta;\r\n\r\n\t\t\t\t\tthis.w = (w * ratioA + this.w * ratioB);\r\n\t\t\t\t\tthis.x = (x * ratioA + this.x * ratioB);\r\n\t\t\t\t\tthis.y = (y * ratioA + this.y * ratioB);\r\n\t\t\t\t\tthis.z = (z * ratioA + this.z * ratioB);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this quaternions equals the given one.\r\n\t *\r\n\t * @param {Quaternion} q - A quaternion.\r\n\t * @return {Boolean} Whether the quaternions are equal.\r\n\t */\r\n\r\n\tequals(q) {\r\n\r\n\t\treturn (q.x === this.x) && (q.y === this.y) && (q.z === this.z) && (q.w === this.w);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs a spherical linear interpolation.\r\n\t *\r\n\t * @param {Quaternion} qa - The base quaternion.\r\n\t * @param {Quaternion} qb - The target quaternion.\r\n\t * @param {Quaternion} qr - A quaternion to store the result in.\r\n\t * @param {Number} t - The slerp factor.\r\n\t * @return {Quaternion} The resulting quaternion.\r\n\t */\r\n\r\n\tstatic slerp(qa, qb, qr, t) {\r\n\r\n\t\treturn qr.copy(qa).slerp(qb, t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs an array-based spherical linear interpolation.\r\n\t *\r\n\t * @param {Number[]} dst - An array to store the result in.\r\n\t * @param {Number} dstOffset - An offset into the destination array.\r\n\t * @param {Number[]} src0 - An array that contains the base quaternion values.\r\n\t * @param {Number} srcOffset0 - An offset into the base array.\r\n\t * @param {Number[]} src1 - An array that contains the target quaternion values.\r\n\t * @param {Number} srcOffset1 - An offset into the target array.\r\n\t * @param {Number} t - The slerp factor.\r\n\t */\r\n\r\n\tstatic slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\r\n\r\n\t\tconst x1 = src1[srcOffset1];\r\n\t\tconst y1 = src1[srcOffset1 + 1];\r\n\t\tconst z1 = src1[srcOffset1 + 2];\r\n\t\tconst w1 = src1[srcOffset1 + 3];\r\n\r\n\t\tlet x0 = src0[srcOffset0];\r\n\t\tlet y0 = src0[srcOffset0 + 1];\r\n\t\tlet z0 = src0[srcOffset0 + 2];\r\n\t\tlet w0 = src0[srcOffset0 + 3];\r\n\r\n\t\tlet s, f;\r\n\t\tlet sin, cos, sqrSin;\r\n\t\tlet dir, len, tDir;\r\n\r\n\t\tif(w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\r\n\r\n\t\t\ts = 1.0 - t;\r\n\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;\r\n\r\n\t\t\tdir = (cos >= 0) ? 1 : -1;\r\n\t\t\tsqrSin = 1.0 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems.\r\n\t\t\tif(sqrSin > Number.EPSILON) {\r\n\r\n\t\t\t\tsin = Math.sqrt(sqrSin);\r\n\t\t\t\tlen = Math.atan2(sin, cos * dir);\r\n\r\n\t\t\t\ts = Math.sin(s * len) / sin;\r\n\t\t\t\tt = Math.sin(t * len) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case a lerp has just been performed.\r\n\t\t\tif(s === 1.0 - t) {\r\n\r\n\t\t\t\tf = 1.0 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[dstOffset] = x0;\r\n\t\tdst[dstOffset + 1] = y0;\r\n\t\tdst[dstOffset + 2] = z0;\r\n\t\tdst[dstOffset + 3] = w0;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * Clamps the given value.\r\n *\r\n * @private\r\n * @param {Number} value - The value.\r\n * @param {Number} min - The lower limit.\r\n * @param {Number} max - The upper limit.\r\n * @return {Number} The clamped value.\r\n */\r\n\r\nfunction clamp(value, min, max) {\r\n\r\n\treturn Math.max(Math.min(value, max), min);\r\n\r\n}\r\n\r\n/**\r\n * A matrix.\r\n *\r\n * @type {Matrix3}\r\n * @private\r\n */\r\n\r\nconst m = new Matrix3();\r\n\r\n/**\r\n * A quaternion.\r\n *\r\n * @type {Quaternion}\r\n * @private\r\n */\r\n\r\nconst q = new Quaternion();\r\n\r\n/**\r\n * Euler angles.\r\n */\r\n\r\nclass Euler {\r\n\r\n\t/**\r\n\t * Constructs a new set of Euler angles.\r\n\t *\r\n\t * @param {Number} [x=0] - The rotation around the X-axis.\r\n\t * @param {Number} [y=0] - The rotation around the Y-axis.\r\n\t * @param {Number} [z=0] - The rotation around the Z-axis.\r\n\t */\r\n\r\n\tconstructor(x = 0, y = 0, z = 0) {\r\n\r\n\t\t/**\r\n\t\t * The rotation around the X-axis.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\t/**\r\n\t\t * The rotation around the Y-axis.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\t/**\r\n\t\t * The rotation around the Z-axis.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\t/**\r\n\t\t * The rotation order.\r\n\t\t *\r\n\t\t * @type {RotationOrder}\r\n\t\t * @default Euler.defaultOrder\r\n\t\t */\r\n\r\n\t\tthis.order = Euler.defaultOrder;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the Euler angles and rotation order.\r\n\t *\r\n\t * @param {Number} x - The rotation around the X-axis.\r\n\t * @param {Number} y - The rotation around the Y-axis.\r\n\t * @param {Number} z - The rotation around the Z-axis.\r\n\t * @param {Number} order - The rotation order.\r\n\t * @return {Euler} This set of Euler angles.\r\n\t */\r\n\r\n\tset(x, y, z, order) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.order = order;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of another set of Euler angles.\r\n\t *\r\n\t * @param {Euler} e - A set of Euler angles.\r\n\t * @return {Euler} This set of Euler angles.\r\n\t */\r\n\r\n\tcopy(e) {\r\n\r\n\t\tthis.x = e.x;\r\n\t\tthis.y = e.y;\r\n\t\tthis.z = e.z;\r\n\t\tthis.order = e.order;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this set of Euler angles.\r\n\t *\r\n\t * @return {Euler} A clone of this set of Euler angles.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor(this.x, this.y, this.z, this.order);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies angles and the rotation order from an array.\r\n\t *\r\n\t * @param {Number[]} array - An array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Euler} This set of Euler angles.\r\n\t */\r\n\r\n\tfromArray(array, offset = 0) {\r\n\r\n\t\tthis.x = array[offset];\r\n\t\tthis.y = array[offset + 1];\r\n\t\tthis.z = array[offset + 2];\r\n\t\tthis.order = array[offset + 3];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this set of Euler angles and the rotation order in an array.\r\n\t *\r\n\t * @param {Array} [array] - A target array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Number[]} The array.\r\n\t */\r\n\r\n\ttoArray(array = [], offset = 0) {\r\n\r\n\t\tarray[offset] = this.x;\r\n\t\tarray[offset + 1] = this.y;\r\n\t\tarray[offset + 2] = this.z;\r\n\t\tarray[offset + 3] = this.order;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this set of Euler angles in a vector.\r\n\t *\r\n\t * @param {Vector3} [vector] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The vector.\r\n\t */\r\n\r\n\ttoVector3(vector = new Vector3()) {\r\n\r\n\t\treturn vector.set(this.x, this.y, this.z);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the rotation from a given matrix.\r\n\t *\r\n\t * @param {Matrix4} m - A rotation matrix. The upper 3x3 is assumed to be a pure rotation matrix (i.e. unscaled).\r\n\t * @param {RotationOrder} [order] - An override rotation order.\r\n\t * @return {Euler} This set of Euler angles.\r\n\t */\r\n\r\n\tsetFromRotationMatrix(m, order = this.order) {\r\n\r\n\t\tconst te = m.elements;\r\n\t\tconst m00 = te[0], m01 = te[4], m02 = te[8];\r\n\t\tconst m10 = te[1], m11 = te[5], m12 = te[9];\r\n\t\tconst m20 = te[2], m21 = te[6], m22 = te[10];\r\n\r\n\t\tconst THRESHOLD = 1.0 - 1e-7;\r\n\r\n\t\tswitch(order) {\r\n\r\n\t\t\tcase RotationOrder.XYZ: {\r\n\r\n\t\t\t\tthis.y = Math.asin(clamp(m02, -1, 1));\r\n\r\n\t\t\t\tif(Math.abs(m02) < THRESHOLD) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2(-m12, m22);\r\n\t\t\t\t\tthis.z = Math.atan2(-m01, m00);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2(m21, m11);\r\n\t\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.YXZ: {\r\n\r\n\t\t\t\tthis.x = Math.asin(-clamp(m12, -1, 1));\r\n\r\n\t\t\t\tif(Math.abs(m12) < THRESHOLD) {\r\n\r\n\t\t\t\t\tthis.y = Math.atan2(m02, m22);\r\n\t\t\t\t\tthis.z = Math.atan2(m10, m11);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.y = Math.atan2(-m20, m00);\r\n\t\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.ZXY: {\r\n\r\n\t\t\t\tthis.x = Math.asin(clamp(m21, -1, 1));\r\n\r\n\t\t\t\tif(Math.abs(m21) < THRESHOLD) {\r\n\r\n\t\t\t\t\tthis.y = Math.atan2(-m20, m22);\r\n\t\t\t\t\tthis.z = Math.atan2(-m01, m11);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.y = 0;\r\n\t\t\t\t\tthis.z = Math.atan2(m10, m00);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.ZYX: {\r\n\r\n\t\t\t\tthis.y = Math.asin(-clamp(m20, -1, 1));\r\n\r\n\t\t\t\tif(Math.abs(m20) < THRESHOLD) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2(m21, m22);\r\n\t\t\t\t\tthis.z = Math.atan2(m10, m00);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = 0;\r\n\t\t\t\t\tthis.z = Math.atan2(-m01, m11);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.YZX: {\r\n\r\n\t\t\t\tthis.z = Math.asin(clamp(m10, -1, 1));\r\n\r\n\t\t\t\tif(Math.abs(m10) < THRESHOLD) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2(-m12, m11);\r\n\t\t\t\t\tthis.y = Math.atan2(-m20, m00);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = 0;\r\n\t\t\t\t\tthis.y = Math.atan2(m02, m22);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.XZY: {\r\n\r\n\t\t\t\tthis.z = Math.asin(-clamp(m01, -1, 1));\r\n\r\n\t\t\t\tif(Math.abs(m01) < THRESHOLD) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2(m21, m11);\r\n\t\t\t\t\tthis.y = Math.atan2(m02, m00);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2(-m12, m22);\r\n\t\t\t\t\tthis.y = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.order = order;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the rotation from a given quaternion.\r\n\t *\r\n\t * @param {Matrix4} q - A quaternion.\r\n\t * @param {RotationOrder} [order] - An override rotation order.\r\n\t * @return {Euler} This set of Euler angles.\r\n\t */\r\n\r\n\tsetFromQuaternion(q, order) {\r\n\r\n\t\tm.makeRotationFromQuaternion(q);\r\n\r\n\t\treturn this.setFromRotationMatrix(m, order);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the rotation from a given vector.\r\n\t *\r\n\t * @param {Matrix4} v - A vector.\r\n\t * @param {RotationOrder} [order] - A rotation order.\r\n\t * @return {Euler} This set of Euler angles.\r\n\t */\r\n\r\n\tsetFromVector3(v, order = this.order) {\r\n\r\n\t\treturn this.set(v.x, v.y, v.z, order);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Reorder the rotation angles.\r\n\t *\r\n\t * WARNING: this operation discards revolution information!\r\n\t *\r\n\t * @param {RotationOrder} newOrder - The new rotation order.\r\n\t * @return {Euler} This set of Euler angles.\r\n\t */\r\n\r\n\treorder(newOrder) {\r\n\r\n\t\tq.setFromEuler(this);\r\n\r\n\t\treturn this.setFromQuaternion(q, newOrder);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this set of Euler angles equals the given one.\r\n\t *\r\n\t * @param {Euler} e - Euler angles.\r\n\t * @return {Boolean} Whether this set of Euler angles equals the given one.\r\n\t */\r\n\r\n\tequals(e) {\r\n\r\n\t\treturn (e.x === this.x && e.y === this.y && e.z === this.z && e.order === this.order);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * The default rotation order.\r\n\t *\r\n\t * @type {RotationOrder}\r\n\t * @final\r\n\t */\r\n\r\n\tstatic get defaultOrder() {\r\n\r\n\t\treturn RotationOrder.XYZ;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst a = new Vector3();\r\n\r\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst b = new Vector3();\r\n\r\n/**\r\n * A plane.\r\n */\r\n\r\nclass Plane {\r\n\r\n\t/**\r\n\t * Constructs a new plane.\r\n\t *\r\n\t * @param {Vector3} [normal] - The normal.\r\n\t * @param {Number} [constant] - The constant.\r\n\t */\r\n\r\n\tconstructor(normal = new Vector3(1, 0, 0), constant = 0) {\r\n\r\n\t\t/**\r\n\t\t * The normal.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.normal = normal;\r\n\r\n\t\t/**\r\n\t\t * The constant.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.constant = constant;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the normal and the constant.\r\n\t *\r\n\t * @param {Vector3} normal - The normal.\r\n\t * @param {Number} constant - The constant.\r\n\t * @return {Plane} This plane.\r\n\t */\r\n\r\n\tset(normal, constant) {\r\n\r\n\t\tthis.normal.copy(normal);\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the components of this plane.\r\n\t *\r\n\t * @param {Number} x - The X component of the normal.\r\n\t * @param {Number} y - The Y component of the normal.\r\n\t * @param {Number} z - The Z component of the normal.\r\n\t * @param {Number} w - The constant.\r\n\t * @return {Plane} This plane.\r\n\t */\r\n\r\n\tsetComponents(x, y, z, w) {\r\n\r\n\t\tthis.normal.set(x, y, z);\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the given plane.\r\n\t *\r\n\t * @param {Plane} p - A plane.\r\n\t * @return {Plane} This plane.\r\n\t */\r\n\r\n\tcopy(p) {\r\n\r\n\t\tthis.normal.copy(p.normal);\r\n\t\tthis.constant = p.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this plane.\r\n\t *\r\n\t * @return {Plane} The cloned plane.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this plane from a normal and a coplanar point.\r\n\t *\r\n\t * @param {Vector3} n - The normal.\r\n\t * @param {Vector3} p - The coplanar point.\r\n\t * @return {Sphere} This sphere.\r\n\t */\r\n\r\n\tsetFromNormalAndCoplanarPoint(n, p) {\r\n\r\n\t\tthis.normal.copy(n);\r\n\t\tthis.constant = -p.dot(this.normal);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this plane from three distinct coplanar points.\r\n\t *\r\n\t * @param {Vector3} p0 - A coplanar point.\r\n\t * @param {Vector3} p1 - A coplanar point.\r\n\t * @param {Vector3} p2 - A coplanar point.\r\n\t * @return {Plane} This plane.\r\n\t */\r\n\r\n\tsetFromCoplanarPoints(p0, p1, p2) {\r\n\r\n\t\tconst normal = a.subVectors(p2, p1).cross(b.subVectors(p0, p1)).normalize();\r\n\r\n\t\tthis.setFromNormalAndCoplanarPoint(normal, a);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes this plane.\r\n\t *\r\n\t * @return {Plane} This plane.\r\n\t */\r\n\r\n\tnormalize() {\r\n\r\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\r\n\r\n\t\tthis.normal.multiplyScalar(inverseNormalLength);\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Negates this plane.\r\n\t *\r\n\t * @return {Plane} This plane.\r\n\t */\r\n\r\n\tnegate() {\r\n\r\n\t\tthis.normal.negate();\r\n\t\tthis.constant = -this.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this plane to the given point.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tdistanceToPoint(p) {\r\n\r\n\t\treturn this.normal.dot(p) + this.constant;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this plane to the given sphere.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tdistanceToSphere(s) {\r\n\r\n\t\treturn this.distanceToPoint(s.center) - s.radius;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Projects the given point on this plane.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The projected point.\r\n\t */\r\n\r\n\tprojectPoint(p, target) {\r\n\r\n\t\treturn target.copy(this.normal).multiplyScalar(-this.distanceToPoint(p)).add(p);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates a coplanar point and returns it.\r\n\t *\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} A coplanar plane.\r\n\t */\r\n\r\n\tcoplanarPoint(target) {\r\n\r\n\t\treturn target.copy(this.normal).multiplyScalar(-this.constant);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Translates this plane.\r\n\t *\r\n\t * @param {Vector3} offset - An offset.\r\n\t * @return {Plane} This plane.\r\n\t */\r\n\r\n\ttranslate(offset) {\r\n\r\n\t\tthis.constant -= offset.dot(this.normal);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the point of intersection between this plane and a given line.\r\n\t *\r\n\t * @param {Line3} l - A line.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The intersection point.\r\n\t */\r\n\r\n\tintersectLine(l, target) {\r\n\r\n\t\tconst direction = l.delta(a);\r\n\t\tconst denominator = this.normal.dot(direction);\r\n\r\n\t\tif(denominator === 0) {\r\n\r\n\t\t\t// The line is coplanar, return origin.\r\n\t\t\tif(this.distanceToPoint(l.start) === 0) {\r\n\r\n\t\t\t\ttarget.copy(l.start);\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst t = -(l.start.dot(this.normal) + this.constant) / denominator;\r\n\r\n\t\t\tif(t >= 0 && t <= 1) {\r\n\r\n\t\t\t\ttarget.copy(direction).multiplyScalar(t).add(l.start);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this plane intersects with the given line.\r\n\t *\r\n\t * @param {Line3} l - A line.\r\n\t * @return {Boolean} Whether this plane intersects with the given line.\r\n\t */\r\n\r\n\tintersectsLine(l) {\r\n\r\n\t\tconst startSign = this.distanceToPoint(l.start);\r\n\t\tconst endSign = this.distanceToPoint(l.end);\r\n\r\n\t\treturn ((startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this plane intersects with the given box.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Boolean} Whether this plane intersects with the given box.\r\n\t */\r\n\r\n\tintersectsBox(b) {\r\n\r\n\t\treturn b.intersectsPlane(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this plane intersects with the given sphere.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @return {Boolean} Whether this plane intersects with the given sphere.\r\n\t */\r\n\r\n\tintersectsSphere(s) {\r\n\r\n\t\treturn s.intersectsPlane(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this plane equals the given one.\r\n\t *\r\n\t * @param {Plane} p - A plane.\r\n\t * @return {Boolean} Whether this plane equals the given one.\r\n\t */\r\n\r\n\tequals(p) {\r\n\r\n\t\treturn (p.normal.equals(this.normal) && (p.constant === this.constant));\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst v$3 = new Vector3();\r\n\r\n/**\r\n * A frustum.\r\n */\r\n\r\nclass Frustum {\r\n\r\n\t/**\r\n\t * Constructs a new frustum.\r\n\t *\r\n\t * @param {Plane} [p0] - A plane.\r\n\t * @param {Plane} [p1] - A plane.\r\n\t * @param {Plane} [p2] - A plane.\r\n\t * @param {Plane} [p3] - A plane.\r\n\t * @param {Plane} [p4] - A plane.\r\n\t * @param {Plane} [p5] - A plane.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tp0 = new Plane(),\r\n\t\tp1 = new Plane(),\r\n\t\tp2 = new Plane(),\r\n\t\tp3 = new Plane(),\r\n\t\tp4 = new Plane(),\r\n\t\tp5 = new Plane()\r\n\t) {\r\n\r\n\t\t/**\r\n\t\t * The six planes that form the frustum.\r\n\t\t *\r\n\t\t * @type {Plane[]}\r\n\t\t */\r\n\r\n\t\tthis.planes = [p0, p1, p2, p3, p4, p5];\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the planes of this frustum.\r\n\t *\r\n\t * @param {Plane} [p0] - A plane.\r\n\t * @param {Plane} [p1] - A plane.\r\n\t * @param {Plane} [p2] - A plane.\r\n\t * @param {Plane} [p3] - A plane.\r\n\t * @param {Plane} [p4] - A plane.\r\n\t * @param {Plane} [p5] - A plane.\r\n\t * @return {Frustum} This frustum.\r\n\t */\r\n\r\n\tset(p0, p1, p2, p3, p4, p5) {\r\n\r\n\t\tconst planes = this.planes;\r\n\r\n\t\tplanes[0].copy(p0);\r\n\t\tplanes[1].copy(p1);\r\n\t\tplanes[2].copy(p2);\r\n\t\tplanes[3].copy(p3);\r\n\t\tplanes[4].copy(p4);\r\n\t\tplanes[5].copy(p5);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this frustum.\r\n\t *\r\n\t * @return {Frustum} The cloned frustum.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies a given frustum.\r\n\t *\r\n\t * @param {Frustum} frustum - A frustum.\r\n\t * @return {Frustum} This frustum.\r\n\t */\r\n\r\n\tcopy(frustum) {\r\n\r\n\t\tconst planes = this.planes;\r\n\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 6; ++i) {\r\n\r\n\t\t\tplanes[i].copy(frustum.planes[i]);\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this frustum based on a given projection matrix.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Frustum} This frustum.\r\n\t * @deprecated Use setFromPerspectiveMatrix instead.\r\n\t */\r\n\r\n\tsetFromMatrix(m) {\r\n\r\n\t\treturn this.setFromProjectionMatrix(m);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this frustum based on a given projection matrix.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Frustum} This frustum.\r\n\t */\r\n\r\n\tsetFromProjectionMatrix(m) {\r\n\r\n\t\tconst planes = this.planes;\r\n\r\n\t\tconst me = m.elements;\r\n\t\tconst me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\r\n\t\tconst me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\r\n\t\tconst me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\r\n\t\tconst me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\r\n\r\n\t\tplanes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\r\n\t\tplanes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\r\n\t\tplanes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\r\n\t\tplanes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\r\n\t\tplanes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\r\n\t\tplanes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this frustum intersects with the given sphere.\r\n\t *\r\n\t * @param {Sphere} sphere - A sphere.\r\n\t * @return {Boolean} Whether this frustum intersects with the sphere.\r\n\t */\r\n\r\n\tintersectsSphere(sphere) {\r\n\r\n\t\tconst planes = this.planes;\r\n\t\tconst center = sphere.center;\r\n\t\tconst negativeRadius = -sphere.radius;\r\n\r\n\t\tlet result = true;\r\n\t\tlet i, d;\r\n\r\n\t\tfor(i = 0; i < 6; ++i) {\r\n\r\n\t\t\td = planes[i].distanceToPoint(center);\r\n\r\n\t\t\tif(d < negativeRadius) {\r\n\r\n\t\t\t\tresult = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this frustum intersects with the given sphere.\r\n\t *\r\n\t * @param {Box3} box - A box.\r\n\t * @return {Boolean} Whether this frustum intersects with the box.\r\n\t */\r\n\r\n\tintersectsBox(box) {\r\n\r\n\t\tconst planes = this.planes;\r\n\t\tconst min = box.min, max = box.max;\r\n\r\n\t\tlet i, plane;\r\n\r\n\t\tfor(i = 0; i < 6; ++i) {\r\n\r\n\t\t\tplane = planes[i];\r\n\r\n\t\t\t// Corner at max distance.\r\n\t\t\tv$3.x = (plane.normal.x > 0.0) ? max.x : min.x;\r\n\t\t\tv$3.y = (plane.normal.y > 0.0) ? max.y : min.y;\r\n\t\t\tv$3.z = (plane.normal.z > 0.0) ? max.z : min.z;\r\n\r\n\t\t\tif(plane.distanceToPoint(v$3) < 0.0) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this frustum contains the given point.\r\n\t *\r\n\t * @param {Vector3} point - A point.\r\n\t * @return {Boolean} Whether this frustum contains the point.\r\n\t */\r\n\r\n\tcontainsPoint(point) {\r\n\r\n\t\tconst planes = this.planes;\r\n\r\n\t\tlet result = true;\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 6; ++i) {\r\n\r\n\t\t\tif(planes[i].distanceToPoint(point) < 0) {\r\n\r\n\t\t\t\tresult = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst a$1 = new Vector3();\r\n\r\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst b$1 = new Vector3();\r\n\r\n/**\r\n * A line.\r\n */\r\n\r\nclass Line3 {\r\n\r\n\t/**\r\n\t * Constructs a new line.\r\n\t *\r\n\t * @param {Vector3} [start] - The starting point. If none is provided, a new vector will be created.\r\n\t * @param {Vector3} [end] - The ending point. If none is provided, a new vector will be created.\r\n\t */\r\n\r\n\tconstructor(start = new Vector3(), end = new Vector3()) {\r\n\r\n\t\t/**\r\n\t\t * The starting point.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.start = start;\r\n\r\n\t\t/**\r\n\t\t * The ending point.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.end = end;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the starting and ending point of this line.\r\n\t *\r\n\t * @param {Vector3} start - The starting point.\r\n\t * @param {Vector3} end - The ending point.\r\n\t * @return {Line3} This line.\r\n\t */\r\n\r\n\tset(start, end) {\r\n\r\n\t\tthis.start.copy(start);\r\n\t\tthis.end.copy(end);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of the given line.\r\n\t *\r\n\t * @param {Line3} l - A line.\r\n\t * @return {Line3} This line.\r\n\t */\r\n\r\n\tcopy(l) {\r\n\r\n\t\tthis.start.copy(l.start);\r\n\t\tthis.end.copy(l.end);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this line.\r\n\t *\r\n\t * @return {Line3} The cloned line.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the center of this line.\r\n\t *\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The center of this line.\r\n\t */\r\n\r\n\tgetCenter(target = new Vector3()) {\r\n\r\n\t\treturn target.addVectors(this.start, this.end).multiplyScalar(0.5);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the delta vector of this line.\r\n\t *\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The delta vector of this line.\r\n\t */\r\n\r\n\tdelta(target = new Vector3()) {\r\n\r\n\t\treturn target.subVectors(this.end, this.start);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared length of this line.\r\n\t *\r\n\t * @return {Vector3} The squared length.\r\n\t */\r\n\r\n\tlengthSquared() {\r\n\r\n\t\treturn this.start.distanceToSquared(this.end);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the length of this line.\r\n\t *\r\n\t * @return {Vector3} The length.\r\n\t */\r\n\r\n\tlength() {\r\n\r\n\t\treturn this.start.distanceTo(this.end);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts this line to point in the given direction.\r\n\t *\r\n\t * @param {Vector3} d - The direction.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The length.\r\n\t */\r\n\r\n\tat(d, target) {\r\n\r\n\t\treturn this.delta(target).multiplyScalar(d).add(this.start);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a point parameter based on the closest point as projected on the line segement.\r\n\t *\r\n\t * @private\r\n\t * @param {Vector3} p - A point.\r\n\t * @param {Boolean} clampToLine - Whether the point should be clamped to the line.\r\n\t * @return {Vector3} The parameter.\r\n\t */\r\n\r\n\tclosestPointToPointParameter(p, clampToLine) {\r\n\r\n\t\ta$1.subVectors(p, this.start);\r\n\t\tb$1.subVectors(this.end, this.start);\r\n\r\n\t\tconst bb = b$1.dot(b$1);\r\n\t\tconst ba = b$1.dot(a$1);\r\n\r\n\t\tconst t = clampToLine ? Math.min(Math.max(ba / bb, 0), 1) : ba / bb;\r\n\r\n\t\treturn t;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the closest point on the line.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @param {Boolean} [clampToLine=false] - Whether the point should be clamped to the line.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The parameter.\r\n\t */\r\n\r\n\tclosestPointToPoint(p, clampToLine = false, target = new Vector3()) {\r\n\r\n\t\tconst t = this.closestPointToPointParameter(p, clampToLine);\r\n\r\n\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this line equals the given one.\r\n\t *\r\n\t * @param {Line3} l - A line.\r\n\t * @return {Boolean} Whether the lines are equal.\r\n\t */\r\n\r\n\tequals(l) {\r\n\r\n\t\treturn l.start.equals(this.start) && l.end.equals(this.end);\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst a$2 = new Vector3();\r\n\r\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst b$2 = new Vector3();\r\n\r\n/**\r\n * A vector.\r\n *\r\n * @type {Vector3}\r\n * @private\r\n */\r\n\r\nconst c = new Vector3();\r\n\r\n/**\r\n * A 4x4 matrix.\r\n */\r\n\r\nclass Matrix4 {\r\n\r\n\t/**\r\n\t * Constructs a new matrix.\r\n\t */\r\n\r\n\tconstructor() {\r\n\r\n\t\t/**\r\n\t\t * The matrix elements.\r\n\t\t *\r\n\t\t * @type {Float32Array}\r\n\t\t */\r\n\r\n\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t]);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this matrix.\r\n\t *\r\n\t * @param {Number} n00 - The value of the first row, first column.\r\n\t * @param {Number} n01 - The value of the first row, second column.\r\n\t * @param {Number} n02 - The value of the first row, third column.\r\n\t * @param {Number} n03 - The value of the first row, fourth column.\r\n\t * @param {Number} n10 - The value of the second row, first column.\r\n\t * @param {Number} n11 - The value of the second row, second column.\r\n\t * @param {Number} n12 - The value of the second row, third column.\r\n\t * @param {Number} n13 - The value of the second row, fourth column.\r\n\t * @param {Number} n20 - The value of the third row, first column.\r\n\t * @param {Number} n21 - The value of the third row, second column.\r\n\t * @param {Number} n22 - The value of the third row, third column.\r\n\t * @param {Number} n23 - The value of the third row, fourth column.\r\n\t * @param {Number} n30 - The value of the fourth row, first column.\r\n\t * @param {Number} n31 - The value of the fourth row, second column.\r\n\t * @param {Number} n32 - The value of the fourth row, third column.\r\n\t * @param {Number} n33 - The value of the fourth row, fourth column.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tset(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] = n00; te[4] = n01; te[8] = n02; te[12] = n03;\r\n\t\tte[1] = n10; te[5] = n11; te[9] = n12; te[13] = n13;\r\n\t\tte[2] = n20; te[6] = n21; te[10] = n22; te[14] = n23;\r\n\t\tte[3] = n30; te[7] = n31; te[11] = n32; te[15] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this matrix to the identity matrix.\r\n\t *\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tidentity() {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a given matrix.\r\n\t *\r\n\t * @param {Matrix4} matrix - A matrix.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tcopy(matrix) {\r\n\r\n\t\tconst me = matrix.elements;\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] = me[0]; te[1] = me[1]; te[2] = me[2]; te[3] = me[3];\r\n\t\tte[4] = me[4]; te[5] = me[5]; te[6] = me[6]; te[7] = me[7];\r\n\t\tte[8] = me[8]; te[9] = me[9]; te[10] = me[10]; te[11] = me[11];\r\n\t\tte[12] = me[12]; te[13] = me[13]; te[14] = me[14]; te[15] = me[15];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this matrix.\r\n\t *\r\n\t * @return {Matrix4} A clone of this matrix.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().fromArray(this.elements);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a given array.\r\n\t *\r\n\t * @param {Number[]} array - An array.\r\n\t * @param {Number} [offset=0] - An offset into the array.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tfromArray(array, offset = 0) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 16; ++i) {\r\n\r\n\t\t\tte[i] = array[i + offset];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this matrix in an array.\r\n\t *\r\n\t * @param {Number[]} [array] - A target array.\r\n\t * @param {Number} [offset=0] - An offset into the array.\r\n\t * @return {Number[]} The array.\r\n\t */\r\n\r\n\ttoArray(array = [], offset = 0) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; i < 16; ++i) {\r\n\r\n\t\t\tarray[i + offset] = te[i];\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the largest scale.\r\n\t *\r\n\t * @return {Number} The largest scale of the three axes.\r\n\t */\r\n\r\n\tgetMaxScaleOnAxis() {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\r\n\t\tconst scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\r\n\t\tconst scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\r\n\r\n\t\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the position values of a given matrix.\r\n\t *\r\n\t * @param {Matrix4} matrix - A matrix.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tcopyPosition(matrix) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = matrix.elements;\r\n\r\n\t\tte[12] = me[12];\r\n\t\tte[13] = me[13];\r\n\t\tte[14] = me[14];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the position values of this matrix.\r\n\t *\r\n\t * @param {Vector3} p - A position.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tsetPosition(p) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[12] = p.x;\r\n\t\tte[13] = p.y;\r\n\t\tte[14] = p.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts the basis from this matrix.\r\n\t *\r\n\t * @param {Vector3} xAxis - A vector to store the X-axis column in.\r\n\t * @param {Vector3} yAxis - A vector to store the Y-axis column in.\r\n\t * @param {Vector3} zAxis - A vector to store the Z-axis column in.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\textractBasis(xAxis, yAxis, zAxis) {\r\n\r\n\t\txAxis.setFromMatrixColumn(this, 0);\r\n\t\tyAxis.setFromMatrixColumn(this, 1);\r\n\t\tzAxis.setFromMatrixColumn(this, 2);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the basis of this matrix.\r\n\t *\r\n\t * @param {Vector3} xAxis - The X-axis.\r\n\t * @param {Vector3} yAxis - The Y-axis.\r\n\t * @param {Vector3} zAxis - The Z-axis.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeBasis(xAxis, yAxis, zAxis) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts the rotation from a given matrix.\r\n\t *\r\n\t * This method does not support reflection matrices.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\textractRotation(m) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tconst scaleX = 1.0 / a$2.setFromMatrixColumn(m, 0).length();\r\n\t\tconst scaleY = 1.0 / a$2.setFromMatrixColumn(m, 1).length();\r\n\t\tconst scaleZ = 1.0 / a$2.setFromMatrixColumn(m, 2).length();\r\n\r\n\t\tte[0] = me[0] * scaleX;\r\n\t\tte[1] = me[1] * scaleX;\r\n\t\tte[2] = me[2] * scaleX;\r\n\t\tte[3] = 0;\r\n\r\n\t\tte[4] = me[4] * scaleY;\r\n\t\tte[5] = me[5] * scaleY;\r\n\t\tte[6] = me[6] * scaleY;\r\n\t\tte[7] = 0;\r\n\r\n\t\tte[8] = me[8] * scaleZ;\r\n\t\tte[9] = me[9] * scaleZ;\r\n\t\tte[10] = me[10] * scaleZ;\r\n\t\tte[11] = 0;\r\n\r\n\t\tte[12] = 0;\r\n\t\tte[13] = 0;\r\n\t\tte[14] = 0;\r\n\t\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the matrix rotation based on the given Euler angles.\r\n\t *\r\n\t * @param {Euler} euler - The euler angles.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeRotationFromEuler(euler) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst x = euler.x;\r\n\t\tconst y = euler.y;\r\n\t\tconst z = euler.z;\r\n\r\n\t\tconst a = Math.cos(x), b = Math.sin(x);\r\n\t\tconst c = Math.cos(y), d = Math.sin(y);\r\n\t\tconst e = Math.cos(z), f = Math.sin(z);\r\n\r\n\t\tlet ae, af, be, bf;\r\n\t\tlet ce, cf, de, df;\r\n\t\tlet ac, ad, bc, bd;\r\n\r\n\t\tswitch(euler.order) {\r\n\r\n\t\t\tcase RotationOrder.XYZ: {\r\n\r\n\t\t\t\tae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\t\tte[0] = c * e;\r\n\t\t\t\tte[4] = -c * f;\r\n\t\t\t\tte[8] = d;\r\n\r\n\t\t\t\tte[1] = af + be * d;\r\n\t\t\t\tte[5] = ae - bf * d;\r\n\t\t\t\tte[9] = -b * c;\r\n\r\n\t\t\t\tte[2] = bf - ae * d;\r\n\t\t\t\tte[6] = be + af * d;\r\n\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.YXZ: {\r\n\r\n\t\t\t\tce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\t\tte[0] = ce + df * b;\r\n\t\t\t\tte[4] = de * b - cf;\r\n\t\t\t\tte[8] = a * d;\r\n\r\n\t\t\t\tte[1] = a * f;\r\n\t\t\t\tte[5] = a * e;\r\n\t\t\t\tte[9] = -b;\r\n\r\n\t\t\t\tte[2] = cf * b - de;\r\n\t\t\t\tte[6] = df + ce * b;\r\n\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.ZXY: {\r\n\r\n\t\t\t\tce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\t\tte[0] = ce - df * b;\r\n\t\t\t\tte[4] = -a * f;\r\n\t\t\t\tte[8] = de + cf * b;\r\n\r\n\t\t\t\tte[1] = cf + de * b;\r\n\t\t\t\tte[5] = a * e;\r\n\t\t\t\tte[9] = df - ce * b;\r\n\r\n\t\t\t\tte[2] = -a * d;\r\n\t\t\t\tte[6] = b;\r\n\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.ZYX: {\r\n\r\n\t\t\t\tae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\t\tte[0] = c * e;\r\n\t\t\t\tte[4] = be * d - af;\r\n\t\t\t\tte[8] = ae * d + bf;\r\n\r\n\t\t\t\tte[1] = c * f;\r\n\t\t\t\tte[5] = bf * d + ae;\r\n\t\t\t\tte[9] = af * d - be;\r\n\r\n\t\t\t\tte[2] = -d;\r\n\t\t\t\tte[6] = b * c;\r\n\t\t\t\tte[10] = a * c;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.YZX: {\r\n\r\n\t\t\t\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\t\tte[0] = c * e;\r\n\t\t\t\tte[4] = bd - ac * f;\r\n\t\t\t\tte[8] = bc * f + ad;\r\n\r\n\t\t\t\tte[1] = f;\r\n\t\t\t\tte[5] = a * e;\r\n\t\t\t\tte[9] = -b * e;\r\n\r\n\t\t\t\tte[2] = -d * e;\r\n\t\t\t\tte[6] = ad * f + bc;\r\n\t\t\t\tte[10] = ac - bd * f;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase RotationOrder.XZY: {\r\n\r\n\t\t\t\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\t\tte[0] = c * e;\r\n\t\t\t\tte[4] = -f;\r\n\t\t\t\tte[8] = d * e;\r\n\r\n\t\t\t\tte[1] = ac * f + bd;\r\n\t\t\t\tte[5] = a * e;\r\n\t\t\t\tte[9] = ad * f - bc;\r\n\r\n\t\t\t\tte[2] = bc * f - ad;\r\n\t\t\t\tte[6] = b * e;\r\n\t\t\t\tte[10] = bd * f + ac;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Bottom row.\r\n\t\tte[3] = 0;\r\n\t\tte[7] = 0;\r\n\t\tte[11] = 0;\r\n\r\n\t\t// Last column.\r\n\t\tte[12] = 0;\r\n\t\tte[13] = 0;\r\n\t\tte[14] = 0;\r\n\t\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the matrix rotation based on the given quaternion.\r\n\t *\r\n\t * @param {Quaternion} q - The quaternion.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeRotationFromQuaternion(q) {\r\n\r\n\t\treturn this.compose(a$2.set(0, 0, 0), q, b$2.set(1, 1, 1));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a rotation that looks at the given target.\r\n\t *\r\n\t * @param {Vector3} eye - The position of the eye.\r\n\t * @param {Vector3} target - The target to look at.\r\n\t * @param {Vector3} up - The up vector.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tlookAt(eye, target, up) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst x = a$2, y = b$2, z = c;\r\n\r\n\t\tz.subVectors(eye, target);\r\n\r\n\t\tif(z.lengthSquared() === 0) {\r\n\r\n\t\t\t// Eye and target are at the same position.\r\n\t\t\tz.z = 1;\r\n\r\n\t\t}\r\n\r\n\t\tz.normalize();\r\n\t\tx.crossVectors(up, z);\r\n\r\n\t\tif(x.lengthSquared() === 0) {\r\n\r\n\t\t\t// Up and z are parallel.\r\n\t\t\tif(Math.abs(up.z) === 1) {\r\n\r\n\t\t\t\tz.x += 1e-4;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tz.z += 1e-4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tz.normalize();\r\n\t\t\tx.crossVectors(up, z);\r\n\r\n\t\t}\r\n\r\n\t\tx.normalize();\r\n\t\ty.crossVectors(z, x);\r\n\r\n\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\r\n\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\r\n\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this matrix to the product of the given matrices.\r\n\t *\r\n\t * @param {Matrix4} a - A matrix.\r\n\t * @param {Matrix4} b - A matrix.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmultiplyMatrices(a, b) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst ae = a.elements;\r\n\t\tconst be = b.elements;\r\n\r\n\t\tconst a00 = ae[0], a01 = ae[4], a02 = ae[8], a03 = ae[12];\r\n\t\tconst a10 = ae[1], a11 = ae[5], a12 = ae[9], a13 = ae[13];\r\n\t\tconst a20 = ae[2], a21 = ae[6], a22 = ae[10], a23 = ae[14];\r\n\t\tconst a30 = ae[3], a31 = ae[7], a32 = ae[11], a33 = ae[15];\r\n\r\n\t\tconst b00 = be[0], b01 = be[4], b02 = be[8], b03 = be[12];\r\n\t\tconst b10 = be[1], b11 = be[5], b12 = be[9], b13 = be[13];\r\n\t\tconst b20 = be[2], b21 = be[6], b22 = be[10], b23 = be[14];\r\n\t\tconst b30 = be[3], b31 = be[7], b32 = be[11], b33 = be[15];\r\n\r\n\t\tte[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\r\n\t\tte[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\r\n\t\tte[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\r\n\t\tte[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\r\n\r\n\t\tte[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\r\n\t\tte[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\tte[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\tte[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\tte[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\r\n\t\tte[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\tte[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\tte[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\tte[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\r\n\t\tte[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\tte[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\tte[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this matrix with the given one.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmultiply(m) {\r\n\r\n\t\treturn this.multiplyMatrices(this, m);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies a given matrix with this one.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tpremultiply(m) {\r\n\r\n\t\treturn this.multiplyMatrices(m, this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this matrix with a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmultiplyScalar(s) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\r\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\r\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\r\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the determinant of this matrix.\r\n\t *\r\n\t * For more details see:\r\n\t *  http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t *\r\n\t * @return {Number} The determinant.\r\n\t */\r\n\r\n\tdeterminant() {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst n00 = te[0], n01 = te[4], n02 = te[8], n03 = te[12];\r\n\t\tconst n10 = te[1], n11 = te[5], n12 = te[9], n13 = te[13];\r\n\t\tconst n20 = te[2], n21 = te[6], n22 = te[10], n23 = te[14];\r\n\t\tconst n30 = te[3], n31 = te[7], n32 = te[11], n33 = te[15];\r\n\r\n\t\tconst n00n11 = n00 * n11, n00n12 = n00 * n12, n00n13 = n00 * n13;\r\n\t\tconst n01n10 = n01 * n10, n01n12 = n01 * n12, n01n13 = n01 * n13;\r\n\t\tconst n02n10 = n02 * n10, n02n11 = n02 * n11, n02n13 = n02 * n13;\r\n\t\tconst n03n10 = n03 * n10, n03n11 = n03 * n11, n03n12 = n03 * n12;\r\n\r\n\t\treturn (\r\n\r\n\t\t\tn30 * (\r\n\t\t\t\tn03n12 * n21 -\r\n\t\t\t\tn02n13 * n21 -\r\n\t\t\t\tn03n11 * n22 +\r\n\t\t\t\tn01n13 * n22 +\r\n\t\t\t\tn02n11 * n23 -\r\n\t\t\t\tn01n12 * n23\r\n\t\t\t) +\r\n\r\n\t\t\tn31 * (\r\n\t\t\t\tn00n12 * n23 -\r\n\t\t\t\tn00n13 * n22 +\r\n\t\t\t\tn03n10 * n22 -\r\n\t\t\t\tn02n10 * n23 +\r\n\t\t\t\tn02n13 * n20 -\r\n\t\t\t\tn03n12 * n20\r\n\t\t\t) +\r\n\r\n\t\t\tn32 * (\r\n\t\t\t\tn00n13 * n21 -\r\n\t\t\t\tn00n11 * n23 -\r\n\t\t\t\tn03n10 * n21 +\r\n\t\t\t\tn01n10 * n23 +\r\n\t\t\t\tn03n11 * n20 -\r\n\t\t\t\tn01n13 * n20\r\n\t\t\t) +\r\n\r\n\t\t\tn33 * (\r\n\t\t\t\t-n02n11 * n20 -\r\n\t\t\t\tn00n12 * n21 +\r\n\t\t\t\tn00n11 * n22 +\r\n\t\t\t\tn02n10 * n21 -\r\n\t\t\t\tn01n10 * n22 +\r\n\t\t\t\tn01n12 * n20\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Inverts the given matrix and stores the result in this matrix.\r\n\t *\r\n\t * For details see:\r\n\t *  http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t *\r\n\t * @param {Matrix4} matrix - The matrix that should be inverted.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tgetInverse(matrix) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = matrix.elements;\r\n\r\n\t\tconst n00 = me[0], n10 = me[1], n20 = me[2], n30 = me[3];\r\n\t\tconst n01 = me[4], n11 = me[5], n21 = me[6], n31 = me[7];\r\n\t\tconst n02 = me[8], n12 = me[9], n22 = me[10], n32 = me[11];\r\n\t\tconst n03 = me[12], n13 = me[13], n23 = me[14], n33 = me[15];\r\n\r\n\t\tconst t00 = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\t\tconst t01 = n03 * n22 * n31 - n02 * n23 * n31 - n03 * n21 * n32 + n01 * n23 * n32 + n02 * n21 * n33 - n01 * n22 * n33;\r\n\t\tconst t02 = n02 * n13 * n31 - n03 * n12 * n31 + n03 * n11 * n32 - n01 * n13 * n32 - n02 * n11 * n33 + n01 * n12 * n33;\r\n\t\tconst t03 = n03 * n12 * n21 - n02 * n13 * n21 - n03 * n11 * n22 + n01 * n13 * n22 + n02 * n11 * n23 - n01 * n12 * n23;\r\n\r\n\t\tconst det = n00 * t00 + n10 * t01 + n20 * t02 + n30 * t03;\r\n\r\n\t\tlet invDet;\r\n\r\n\t\tif(det !== 0) {\r\n\r\n\t\t\tinvDet = 1.0 / det;\r\n\r\n\t\t\tte[0] = t00 * invDet;\r\n\t\t\tte[1] = (n13 * n22 * n30 - n12 * n23 * n30 - n13 * n20 * n32 + n10 * n23 * n32 + n12 * n20 * n33 - n10 * n22 * n33) * invDet;\r\n\t\t\tte[2] = (n11 * n23 * n30 - n13 * n21 * n30 + n13 * n20 * n31 - n10 * n23 * n31 - n11 * n20 * n33 + n10 * n21 * n33) * invDet;\r\n\t\t\tte[3] = (n12 * n21 * n30 - n11 * n22 * n30 - n12 * n20 * n31 + n10 * n22 * n31 + n11 * n20 * n32 - n10 * n21 * n32) * invDet;\r\n\r\n\t\t\tte[4] = t01 * invDet;\r\n\t\t\tte[5] = (n02 * n23 * n30 - n03 * n22 * n30 + n03 * n20 * n32 - n00 * n23 * n32 - n02 * n20 * n33 + n00 * n22 * n33) * invDet;\r\n\t\t\tte[6] = (n03 * n21 * n30 - n01 * n23 * n30 - n03 * n20 * n31 + n00 * n23 * n31 + n01 * n20 * n33 - n00 * n21 * n33) * invDet;\r\n\t\t\tte[7] = (n01 * n22 * n30 - n02 * n21 * n30 + n02 * n20 * n31 - n00 * n22 * n31 - n01 * n20 * n32 + n00 * n21 * n32) * invDet;\r\n\r\n\t\t\tte[8] = t02 * invDet;\r\n\t\t\tte[9] = (n03 * n12 * n30 - n02 * n13 * n30 - n03 * n10 * n32 + n00 * n13 * n32 + n02 * n10 * n33 - n00 * n12 * n33) * invDet;\r\n\t\t\tte[10] = (n01 * n13 * n30 - n03 * n11 * n30 + n03 * n10 * n31 - n00 * n13 * n31 - n01 * n10 * n33 + n00 * n11 * n33) * invDet;\r\n\t\t\tte[11] = (n02 * n11 * n30 - n01 * n12 * n30 - n02 * n10 * n31 + n00 * n12 * n31 + n01 * n10 * n32 - n00 * n11 * n32) * invDet;\r\n\r\n\t\t\tte[12] = t03 * invDet;\r\n\t\t\tte[13] = (n02 * n13 * n20 - n03 * n12 * n20 + n03 * n10 * n22 - n00 * n13 * n22 - n02 * n10 * n23 + n00 * n12 * n23) * invDet;\r\n\t\t\tte[14] = (n03 * n11 * n20 - n01 * n13 * n20 - n03 * n10 * n21 + n00 * n13 * n21 + n01 * n10 * n23 - n00 * n11 * n23) * invDet;\r\n\t\t\tte[15] = (n01 * n12 * n20 - n02 * n11 * n20 + n02 * n10 * n21 - n00 * n12 * n21 - n01 * n10 * n22 + n00 * n11 * n22) * invDet;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Transposes this matrix.\r\n\t *\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\ttranspose() {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tlet t;\r\n\r\n\t\tt = te[1]; te[1] = te[4]; te[4] = t;\r\n\t\tt = te[2]; te[2] = te[8]; te[8] = t;\r\n\t\tt = te[6]; te[6] = te[9]; te[9] = t;\r\n\r\n\t\tt = te[3]; te[3] = te[12]; te[12] = t;\r\n\t\tt = te[7]; te[7] = te[13]; te[13] = t;\r\n\t\tt = te[11]; te[11] = te[14]; te[14] = t;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Scales this matrix.\r\n\t *\r\n\t * @param {Number} sx - The X scale.\r\n\t * @param {Number} sy - The Y scale.\r\n\t * @param {Number} sz - The Z scale.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tscale(sx, sy, sz) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[0] *= sx; te[4] *= sy; te[8] *= sz;\r\n\t\tte[1] *= sx; te[5] *= sy; te[9] *= sz;\r\n\t\tte[2] *= sx; te[6] *= sy; te[10] *= sz;\r\n\t\tte[3] *= sx; te[7] *= sy; te[11] *= sz;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this matrix a scale matrix.\r\n\t *\r\n\t * @param {Number} x - The X scale.\r\n\t * @param {Number} y - The Y scale.\r\n\t * @param {Number} z - The Z scale.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeScale(x, y, z) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this matrix a translation matrix.\r\n\t *\r\n\t * @param {Number} x - The X offset.\r\n\t * @param {Number} y - The Y offset.\r\n\t * @param {Number} z - The Z offset.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeTranslation(x, y, z) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this matrix a rotation matrix.\r\n\t *\r\n\t * @param {Number} theta - The angle in radians.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeRotationX(theta) {\r\n\r\n\t\tconst c = Math.cos(theta), s = Math.sin(theta);\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, c, -s, 0,\r\n\t\t\t0, s, c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this matrix a rotation matrix with respect to the Y-axis.\r\n\t *\r\n\t * @param {Number} theta - The angle in radians.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeRotationY(theta) {\r\n\r\n\t\tconst c = Math.cos(theta), s = Math.sin(theta);\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, 0, s, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t-s, 0, c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this matrix a rotation matrix with respect to the Z-axis.\r\n\t *\r\n\t * @param {Number} theta - The angle in radians.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeRotationZ(theta) {\r\n\r\n\t\tconst c = Math.cos(theta), s = Math.sin(theta);\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, -s, 0, 0,\r\n\t\t\ts, c, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this matrix a translation matrix with respect to a specific axis.\r\n\t *\r\n\t * For mor einformation see:\r\n\t *  http://www.gamedev.net/reference/articles/article1199.asp\r\n\t *\r\n\t * @param {Vector3} axis - The axis. Assumed to be normalized.\r\n\t * @param {Number} angle - The angle in radians.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeRotationAxis(axis, angle) {\r\n\r\n\t\tconst c = Math.cos(angle);\r\n\t\tconst s = Math.sin(angle);\r\n\r\n\t\tconst t = 1.0 - c;\r\n\r\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\r\n\t\tconst tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Makes this matrix a shear matrix.\r\n\t *\r\n\t * @param {Number} x - The X shear value.\r\n\t * @param {Number} y - The Y shear value.\r\n\t * @param {Number} z - The Z shear value.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeShear(x, y, z) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, y, z, 0,\r\n\t\t\tx, 1, z, 0,\r\n\t\t\tx, y, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this matrix based on the given position, rotation and scale.\r\n\t *\r\n\t * @param {Vector3} position - The position.\r\n\t * @param {Quaternion} quaternion - The rotation.\r\n\t * @param {Vector3} scale - The scale.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tcompose(position, quaternion, scale) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\r\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\r\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n\t\tte[0] = (1 - (yy + zz)) * sx;\r\n\t\tte[1] = (xy + wz) * sx;\r\n\t\tte[2] = (xz - wy) * sx;\r\n\t\tte[3] = 0;\r\n\r\n\t\tte[4] = (xy - wz) * sy;\r\n\t\tte[5] = (1 - (xx + zz)) * sy;\r\n\t\tte[6] = (yz + wx) * sy;\r\n\t\tte[7] = 0;\r\n\r\n\t\tte[8] = (xz + wy) * sz;\r\n\t\tte[9] = (yz - wx) * sz;\r\n\t\tte[10] = (1 - (xx + yy)) * sz;\r\n\t\tte[11] = 0;\r\n\r\n\t\tte[12] = position.x;\r\n\t\tte[13] = position.y;\r\n\t\tte[14] = position.z;\r\n\t\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Decomposes this matrix into a position, rotation and scale vector.\r\n\t *\r\n\t * @param {Vector3} position - The target position.\r\n\t * @param {Quaternion} quaternion - The target rotation.\r\n\t * @param {Vector3} scale - The target scale.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tdecompose(position, quaternion, scale) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst n00 = te[0], n10 = te[1], n20 = te[2];\r\n\t\tconst n01 = te[4], n11 = te[5], n21 = te[6];\r\n\t\tconst n02 = te[8], n12 = te[9], n22 = te[10];\r\n\r\n\t\tconst det = this.determinant();\r\n\r\n\t\t// If the determinant is negative, one scale must be inverted.\r\n\t\tconst sx = a$2.set(n00, n10, n20).length() * ((det < 0) ? -1 : 1);\r\n\t\tconst sy = a$2.set(n01, n11, n21).length();\r\n\t\tconst sz = a$2.set(n02, n12, n22).length();\r\n\r\n\t\tconst invSX = 1.0 / sx;\r\n\t\tconst invSY = 1.0 / sy;\r\n\t\tconst invSZ = 1.0 / sz;\r\n\r\n\t\t// Export the position.\r\n\t\tposition.x = te[12];\r\n\t\tposition.y = te[13];\r\n\t\tposition.z = te[14];\r\n\r\n\t\t// Scale the rotation part.\r\n\t\tte[0] *= invSX; te[1] *= invSX; te[2] *= invSX;\r\n\t\tte[4] *= invSY; te[5] *= invSY; te[6] *= invSY;\r\n\t\tte[8] *= invSZ; te[9] *= invSZ; te[10] *= invSZ;\r\n\r\n\t\t// Export the rotation.\r\n\t\tquaternion.setFromRotationMatrix(this);\r\n\r\n\t\t// Restore the original values.\r\n\t\tte[0] = n00; te[1] = n10; te[2] = n20;\r\n\t\tte[4] = n01; te[5] = n11; te[6] = n21;\r\n\t\tte[8] = n02; te[9] = n12; te[10] = n22;\r\n\r\n\t\t// Export the scale.\r\n\t\tscale.x = sx;\r\n\t\tscale.y = sy;\r\n\t\tscale.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a perspective matrix.\r\n\t *\r\n\t * @param {Number} left - The distance to the left plane.\r\n\t * @param {Number} right - The distance to the right plane.\r\n\t * @param {Number} top - The distance to the top plane.\r\n\t * @param {Number} bottom - The distance to the bottom plane.\r\n\t * @param {Number} near - The distance to the near plane.\r\n\t * @param {Number} far - The distance to the far plane.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakePerspective(left, right, top, bottom, near, far) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst x = 2 * near / (right - left);\r\n\t\tconst y = 2 * near / (top - bottom);\r\n\r\n\t\tconst a = (right + left) / (right - left);\r\n\t\tconst b = (top + bottom) / (top - bottom);\r\n\t\tconst c = -(far + near) / (far - near);\r\n\t\tconst d = -2 * far * near / (far - near);\r\n\r\n\t\tte[0] = x; te[4] = 0; te[8] = a; te[12] = 0;\r\n\t\tte[1] = 0; te[5] = y; te[9] = b; te[13] = 0;\r\n\t\tte[2] = 0; te[6] = 0; te[10] = c; te[14] = d;\r\n\t\tte[3] = 0; te[7] = 0; te[11] = -1; te[15] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an orthographic matrix.\r\n\t *\r\n\t * @param {Number} left - The distance to the left plane.\r\n\t * @param {Number} right - The distance to the right plane.\r\n\t * @param {Number} top - The distance to the top plane.\r\n\t * @param {Number} bottom - The distance to the bottom plane.\r\n\t * @param {Number} near - The distance to the near plane.\r\n\t * @param {Number} far - The distance to the far plane.\r\n\t * @return {Matrix4} This matrix.\r\n\t */\r\n\r\n\tmakeOrthographic(left, right, top, bottom, near, far) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst w = 1.0 / (right - left);\r\n\t\tconst h = 1.0 / (top - bottom);\r\n\t\tconst p = 1.0 / (far - near);\r\n\r\n\t\tconst x = (right + left) * w;\r\n\t\tconst y = (top + bottom) * h;\r\n\t\tconst z = (far + near) * p;\r\n\r\n\t\tte[0] = 2 * w; te[4] = 0; te[8] = 0; te[12] = -x;\r\n\t\tte[1] = 0; te[5] = 2 * h; te[9] = 0; te[13] = -y;\r\n\t\tte[2] = 0; te[6] = 0; te[10] = -2 * p; te[14] = -z;\r\n\t\tte[3] = 0; te[7] = 0; te[11] = 0; te[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this matrix equals the given one.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Boolean} Whether the matrix are equal.\r\n\t */\r\n\r\n\tequals(m) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tlet result = true;\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; result && i < 16; ++i) {\r\n\r\n\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\tresult = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A list of vectors.\r\n *\r\n * @type {Vector3[]}\r\n * @private\r\n */\r\n\r\nconst v$4 = [\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3(),\r\n\tnew Vector3()\r\n];\r\n\r\n/**\r\n * A ray.\r\n */\r\n\r\nclass Ray {\r\n\r\n\t/**\r\n\t * Constructs a new ray.\r\n\t *\r\n\t * @param {Vector3} [origin] - The origin.\r\n\t * @param {Vector3} [direction] - The direction.\r\n\t */\r\n\r\n\tconstructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\r\n\r\n\t\t/**\r\n\t\t * The origin.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.origin = origin;\r\n\r\n\t\t/**\r\n\t\t * The direction.\r\n\t\t *\r\n\t\t * @type {Vector3}\r\n\t\t */\r\n\r\n\t\tthis.direction = direction;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the origin and the direction.\r\n\t *\r\n\t * @param {Vector3} origin - The origin.\r\n\t * @param {Vector3} direction - The direction. Should be normalized.\r\n\t * @return {Ray} This ray.\r\n\t */\r\n\r\n\tset(origin, direction) {\r\n\r\n\t\tthis.origin.copy(origin);\r\n\t\tthis.direction.copy(direction);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the given ray.\r\n\t *\r\n\t * @param {Ray} r - A ray.\r\n\t * @return {Ray} This ray.\r\n\t */\r\n\r\n\tcopy(r) {\r\n\r\n\t\tthis.origin.copy(r.origin);\r\n\t\tthis.direction.copy(r.direction);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this ray.\r\n\t *\r\n\t * @return {Ray} The cloned ray.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Computes a point along the ray based on a given scalar t.\r\n\t *\r\n\t * @param {Number} t - The scalar.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The point.\r\n\t */\r\n\r\n\tat(t, target = new Vector3()) {\r\n\r\n\t\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rotates this ray to look at the given target.\r\n\t *\r\n\t * @param {Vector3} target - A point to look at.\r\n\t * @return {Ray} This ray.\r\n\t */\r\n\r\n\tlookAt(target) {\r\n\r\n\t\tthis.direction.copy(target).sub(this.origin).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Moves the origin along the ray by a given scalar t.\r\n\t *\r\n\t * @param {Number} t - The scalar.\r\n\t * @return {Ray} This ray.\r\n\t */\r\n\r\n\trecast(t) {\r\n\r\n\t\tthis.origin.copy(this.at(t, v$4[0]));\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the closest point along this ray to a given point.\r\n\t *\r\n\t * @param {Vector3} p - A point.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The point.\r\n\t */\r\n\r\n\tclosestPointToPoint(p, target = new Vector3()) {\r\n\r\n\t\tconst directionDistance = target.subVectors(p, this.origin).dot(this.direction);\r\n\r\n\t\treturn (directionDistance >= 0.0) ?\r\n\t\t\ttarget.copy(this.direction).multiplyScalar(directionDistance).add(this.origin) :\r\n\t\t\ttarget.copy(this.origin);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared distance from this ray to the given point.\r\n\t *\r\n\t * @param {Vector3} p - The point.\r\n\t * @return {Number} The squared distance.\r\n\t */\r\n\r\n\tdistanceSquaredToPoint(p) {\r\n\r\n\t\tconst directionDistance = v$4[0].subVectors(p, this.origin).dot(this.direction);\r\n\r\n\t\t// Check if the point is behind the ray.\r\n\t\treturn (directionDistance < 0.0) ?\r\n\t\t\tthis.origin.distanceToSquared(p) :\r\n\t\t\tv$4[0].copy(this.direction).multiplyScalar(directionDistance).add(this.origin).distanceToSquared(p);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this ray to the given point.\r\n\t *\r\n\t * @param {Vector3} p - The point.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tdistanceToPoint(p) {\r\n\r\n\t\treturn Math.sqrt(this.distanceSquaredToPoint(p));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this ray to the given plane.\r\n\t *\r\n\t * @param {Plane} p - The plane.\r\n\t * @return {Number} The distance, or null if the denominator is zero.\r\n\t */\r\n\r\n\tdistanceToPlane(p) {\r\n\r\n\t\tconst denominator = p.normal.dot(this.direction);\r\n\r\n\t\tconst t = (denominator !== 0.0) ?\r\n\t\t\t-(this.origin.dot(p.normal) + p.constant) / denominator :\r\n\t\t\t((p.distanceToPoint(this.origin) === 0.0) ? 0.0 : -1.0);\r\n\r\n\t\treturn (t >= 0.0) ? t : null;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance from this ray to a given line segment.\r\n\t *\r\n\t * Based on:\r\n\t *  http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t *\r\n\t * @param {Vector3} v0 - The start of the segment.\r\n\t * @param {Vector3} v1 - The end of the segment.\r\n\t * @param {Vector3} [pointOnRay] - If provided, the point on this Ray that is closest to the segment will be stored in this vector.\r\n\t * @param {Vector3} [pointOnSegment] - If provided, the point on the line segment that is closest to this ray will be stored in this vector.\r\n\t * @return {Number} The smallest distance between the ray and the segment defined by v0 and v1.\r\n\t */\r\n\r\n\tdistanceSquaredToSegment(v0, v1, pointOnRay, pointOnSegment) {\r\n\r\n\t\tconst segCenter = v$4[0].copy(v0).add(v1).multiplyScalar(0.5);\r\n\t\tconst segDir = v$4[1].copy(v1).sub(v0).normalize();\r\n\t\tconst diff = v$4[2].copy(this.origin).sub(segCenter);\r\n\r\n\t\tconst segExtent = v0.distanceTo(v1) * 0.5;\r\n\t\tconst a01 = -this.direction.dot(segDir);\r\n\t\tconst b0 = diff.dot(this.direction);\r\n\t\tconst b1 = -diff.dot(segDir);\r\n\t\tconst c = diff.lengthSq();\r\n\t\tconst det = Math.abs(1.0 - a01 * a01);\r\n\r\n\t\tlet s0, s1, extDet, invDet, sqrDist;\r\n\r\n\t\tif(det > 0.0) {\r\n\r\n\t\t\t// The ray and segment are not parallel.\r\n\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\textDet = segExtent * det;\r\n\r\n\t\t\tif(s0 >= 0.0) {\r\n\r\n\t\t\t\tif(s1 >= -extDet) {\r\n\r\n\t\t\t\t\tif(s1 <= extDet) {\r\n\r\n\t\t\t\t\t\t// Region 0.\r\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\t\t\t\t\tinvDet = 1.0 / det;\r\n\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\tsqrDist = s0 * (s0 + a01 * s1 + 2.0 * b0) + s1 * (a01 * s0 + s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Region 1.\r\n\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Region 5.\r\n\t\t\t\t\ts1 = -segExtent;\r\n\t\t\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif(s1 <= -extDet) {\r\n\r\n\t\t\t\t\t// Region 4.\r\n\t\t\t\t\ts0 = Math.max(0.0, -(-a01 * segExtent + b0));\r\n\t\t\t\t\ts1 = (s0 > 0.0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t} else if(s1 <= extDet) {\r\n\r\n\t\t\t\t\t// Region 3.\r\n\t\t\t\t\ts0 = 0.0;\r\n\t\t\t\t\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\tsqrDist = s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Region 2.\r\n\t\t\t\t\ts0 = Math.max(0.0, -(a01 * segExtent + b0));\r\n\t\t\t\t\ts1 = (s0 > 0.0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Ray and segment are parallel.\r\n\t\t\ts1 = (a01 > 0.0) ? -segExtent : segExtent;\r\n\t\t\ts0 = Math.max(0.0, -(a01 * s1 + b0));\r\n\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\r\n\r\n\t\t}\r\n\r\n\t\tif(pointOnRay !== undefined) {\r\n\r\n\t\t\tpointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\r\n\r\n\t\t}\r\n\r\n\t\tif(pointOnSegment !== undefined) {\r\n\r\n\t\t\tpointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\r\n\r\n\t\t}\r\n\r\n\t\treturn sqrDist;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the point where this ray intersects the given sphere.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t */\r\n\r\n\tintersectSphere(s, target = new Vector3()) {\r\n\r\n\t\tconst ab = v$4[0].subVectors(s.center, this.origin);\r\n\t\tconst tca = ab.dot(this.direction);\r\n\t\tconst d2 = ab.dot(ab) - tca * tca;\r\n\t\tconst radius2 = s.radius * s.radius;\r\n\r\n\t\tlet result = null;\r\n\t\tlet thc, t0, t1;\r\n\r\n\t\tif(d2 <= radius2) {\r\n\r\n\t\t\tthc = Math.sqrt(radius2 - d2);\r\n\r\n\t\t\t// t0 = first intersection point - entrance on front of sphere.\r\n\t\t\tt0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersection point - exit point on back of sphere.\r\n\t\t\tt1 = tca + thc;\r\n\r\n\t\t\t// Check if both t0 and t1 are behind the ray - if so, return null.\r\n\t\t\tif(t0 >= 0.0 || t1 >= 0.0) {\r\n\r\n\t\t\t\t/* Check if t0 is behind the ray. If it is, the ray is inside the\r\n\t\t\t\tsphere, so return the second exit point scaled by t1 in order to always\r\n\t\t\t\treturn an intersection point that is in front of the ray. If t0 is in\r\n\t\t\t\tfront of the ray, return the first collision point scaled by t0. */\r\n\t\t\t\tresult = (t0 < 0.0) ? this.at(t1, target) : this.at(t0, target);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Determines whether this ray intersects the given sphere.\r\n\t *\r\n\t * @param {Sphere} s - A sphere.\r\n\t * @return {Boolean} Whether this ray intersects the given sphere.\r\n\t */\r\n\r\n\tintersectsSphere(s) {\r\n\r\n\t\treturn (this.distanceSqToPoint(s.center) <= (s.radius * s.radius));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the point where this ray intersects the given plane.\r\n\t *\r\n\t * @param {Plane} p - A plane.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t */\r\n\r\n\tintersectPlane(p, target = new Vector3()) {\r\n\r\n\t\tconst t = this.distanceToPlane(p);\r\n\r\n\t\treturn (t === null) ? null : this.at(t, target);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Determines whether this ray intersects the given plane.\r\n\t *\r\n\t * @param {Plane} p - A plane.\r\n\t * @return {Boolean} Whether this ray intersects the given plane.\r\n\t */\r\n\r\n\tintersectsPlane(p) {\r\n\r\n\t\tconst distanceToPoint = p.distanceToPoint(this.origin);\r\n\r\n\t\treturn (distanceToPoint === 0.0 || p.normal.dot(this.direction) * distanceToPoint < 0.0);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the point where this ray intersects the given box.\r\n\t *\r\n\t * @param {Plane} b - A box.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t */\r\n\r\n\tintersectBox(b, target = new Vector3()) {\r\n\r\n\t\tconst origin = this.origin;\r\n\t\tconst direction = this.direction;\r\n\t\tconst min = b.min;\r\n\t\tconst max = b.max;\r\n\r\n\t\tconst invDirX = 1.0 / direction.x;\r\n\t\tconst invDirY = 1.0 / direction.y;\r\n\t\tconst invDirZ = 1.0 / direction.z;\r\n\r\n\t\tlet result = null;\r\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tif(invDirX >= 0.0) {\r\n\r\n\t\t\ttmin = (min.x - origin.x) * invDirX;\r\n\t\t\ttmax = (max.x - origin.x) * invDirX;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = (max.x - origin.x) * invDirX;\r\n\t\t\ttmax = (min.x - origin.x) * invDirX;\r\n\r\n\t\t}\r\n\r\n\t\tif(invDirY >= 0.0) {\r\n\r\n\t\t\ttymin = (min.y - origin.y) * invDirY;\r\n\t\t\ttymax = (max.y - origin.y) * invDirY;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = (max.y - origin.y) * invDirY;\r\n\t\t\ttymax = (min.y - origin.y) * invDirY;\r\n\r\n\t\t}\r\n\r\n\t\tif(tmin <= tymax && tymin <= tmax) {\r\n\r\n\t\t\t/* Handle the case where tmin or tmax is NaN (result of 0 * Infinity).\r\n\t\t\tNote: x !== x returns true if x is NaN. */\r\n\t\t\tif(tymin > tmin || tmin !== tmin) {\r\n\r\n\t\t\t\ttmin = tymin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(tymax < tmax || tmax !== tmax) {\r\n\r\n\t\t\t\ttmax = tymax;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(invDirZ >= 0.0) {\r\n\r\n\t\t\t\ttzmin = (min.z - origin.z) * invDirZ;\r\n\t\t\t\ttzmax = (max.z - origin.z) * invDirZ;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttzmin = (max.z - origin.z) * invDirZ;\r\n\t\t\t\ttzmax = (min.z - origin.z) * invDirZ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif(tmin <= tzmax && tzmin <= tmax) {\r\n\r\n\t\t\t\tif(tzmin > tmin || tmin !== tmin) {\r\n\r\n\t\t\t\t\ttmin = tzmin;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(tzmax < tmax || tmax !== tmax) {\r\n\r\n\t\t\t\t\ttmax = tzmax;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Return the closest point (positive side).\r\n\t\t\t\tif(tmax >= 0.0) {\r\n\r\n\t\t\t\t\tresult = this.at((tmin >= 0.0) ? tmin : tmax, target);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Determines whether this ray intersects the given box.\r\n\t *\r\n\t * @param {Box3} b - A box.\r\n\t * @return {Boolean} Whether this ray intersects the given box.\r\n\t */\r\n\r\n\tintersectsBox(b) {\r\n\r\n\t\treturn (this.intersectBox(b, v$4[0]) !== null);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the point where this ray intersects the given triangle.\r\n\t *\r\n\t * Based on:\r\n\t *  http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\t *\r\n\t * @param {Vector3} a - A triangle vertex.\r\n\t * @param {Vector3} b - A triangle vertex.\r\n\t * @param {Vector3} c - A triangle vertex.\r\n\t * @param {Boolean} [backfaceCulling=false] - Whether backface culling should be considered.\r\n\t * @param {Vector3} [target] - A target vector. If none is provided, a new one will be created.\r\n\t * @return {Vector3} The point of intersection, or null if there is none.\r\n\t */\r\n\r\n\tintersectTriangle(a, b, c, backfaceCulling, target) {\r\n\r\n\t\tconst direction = this.direction;\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tconst diff = v$4[0];\r\n\t\tconst edge1 = v$4[1];\r\n\t\tconst edge2 = v$4[2];\r\n\t\tconst normal = v$4[3];\r\n\r\n\t\tlet result = null;\r\n\t\tlet DdN, sign, DdQxE2, DdE1xQ, QdN;\r\n\r\n\t\tedge1.subVectors(b, a);\r\n\t\tedge2.subVectors(c, a);\r\n\t\tnormal.crossVectors(edge1, edge2);\r\n\r\n\t\t/* Solve Q + t * D = b1 * E1 + b2 * E2\r\n\t\t * (Q = kDiff, D = ray direction, E1 = kEdge1, E2 = kEdge2,\r\n\t\t * N = Cross(E1, E2)):\r\n\t\t *\r\n\t\t *   | Dot(D, N) | * b1 = sign(Dot(D, N)) * Dot(D, Cross(Q, E2))\r\n\t\t *   | Dot(D, N) | * b2 = sign(Dot(D, N)) * Dot(D, Cross(E1, Q))\r\n\t\t *   | Dot(D, N) | * t = -sign(Dot(D, N)) * Dot(Q, N)\r\n\t\t */\r\n\r\n\t\tDdN = direction.dot(normal);\r\n\r\n\t\t// Discard coplanar constellations and cull backfaces.\r\n\t\tif(DdN !== 0.0 && !(backfaceCulling && DdN > 0.0)) {\r\n\r\n\t\t\tif(DdN > 0.0) {\r\n\r\n\t\t\t\tsign = 1.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsign = -1.0;\r\n\t\t\t\tDdN = -DdN;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors(this.origin, a);\r\n\t\t\tDdQxE2 = sign * direction.dot(edge2.crossVectors(diff, edge2));\r\n\r\n\t\t\t// b1 < 0, no intersection.\r\n\t\t\tif(DdQxE2 >= 0.0) {\r\n\r\n\t\t\t\tDdE1xQ = sign * direction.dot(edge1.cross(diff));\r\n\r\n\t\t\t\t// b2 < 0, or b1 + b2 > 1, no intersection.\r\n\t\t\t\tif(DdE1xQ >= 0.0 && DdQxE2 + DdE1xQ <= DdN) {\r\n\r\n\t\t\t\t\t// The line intersects the triangle, check if the ray does.\r\n\t\t\t\t\tQdN = -sign * diff.dot(normal);\r\n\r\n\t\t\t\t\t// t < 0, no intersection.\r\n\t\t\t\t\tif(QdN >= 0.0) {\r\n\r\n\t\t\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\t\t\tresult = this.at(QdN / DdN, target);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies the given matrix to this ray.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Ray} This ray.\r\n\t */\r\n\r\n\tapplyMatrix4(m) {\r\n\r\n\t\tthis.origin.applyMatrix4(m);\r\n\t\tthis.direction.transformDirection(m);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this ray equals the given one.\r\n\t *\r\n\t * @param {Ray} r - A ray.\r\n\t * @return {Boolean} Whether the rays are equal.\r\n\t */\r\n\r\n\tequals(r) {\r\n\r\n\t\treturn (r.origin.equals(this.origin) && r.direction.equals(this.direction));\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A spherical coordinate system.\r\n *\r\n * For details see: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The poles (phi) are at the positive and negative Y-axis. The equator starts\r\n * at positive Z.\r\n */\r\n\r\nclass Spherical {\r\n\r\n\t/**\r\n\t * Constructs a new spherical system.\r\n\t *\r\n\t * @param {Number} [radius=1] - The radius of the sphere.\r\n\t * @param {Number} [phi=0] - The polar angle phi.\r\n\t * @param {Number} [theta=0] - The equator angle theta.\r\n\t */\r\n\r\n\tconstructor(radius = 1, phi = 0, theta = 0) {\r\n\r\n\t\t/**\r\n\t\t * The radius of the sphere.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.radius = radius;\r\n\r\n\t\t/**\r\n\t\t * The polar angle, up and down towards the top and bottom pole.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.phi = phi;\r\n\r\n\t\t/**\r\n\t\t * The angle around the equator of the sphere.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.theta = theta;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this spherical system.\r\n\t *\r\n\t * @param {Number} radius - The radius.\r\n\t * @param {Number} phi - Phi.\r\n\t * @param {Number} theta - Theta.\r\n\t * @return {Spherical} This spherical system.\r\n\t */\r\n\r\n\tset(radius, phi, theta) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.phi = phi;\r\n\t\tthis.theta = theta;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of the given spherical system.\r\n\t *\r\n\t * @param {Spherical} s - A spherical system.\r\n\t * @return {Spherical} This spherical system.\r\n\t */\r\n\r\n\tcopy(s) {\r\n\r\n\t\tthis.radius = s.radius;\r\n\t\tthis.phi = s.phi;\r\n\t\tthis.theta = s.theta;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this spherical system.\r\n\t *\r\n\t * @return {Spherical} The cloned spherical system.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Restricts phi to `[1e-6, PI - 1e-6]`.\r\n\t *\r\n\t * @return {Spherical} This spherical system.\r\n\t */\r\n\r\n\tmakeSafe() {\r\n\r\n\t\tthis.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this spherical system based on a vector.\r\n\t *\r\n\t * The radius is set to the vector's length while phi and theta are set from\r\n\t * its direction.\r\n\t *\r\n\t * @param {Vector3} v - The vector.\r\n\t * @return {Spherical} This spherical system.\r\n\t */\r\n\r\n\tsetFromVector3(v) {\r\n\r\n\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this spherical system based on cartesian coordinates.\r\n\t *\r\n\t * @param {Number} x - The X coordinate.\r\n\t * @param {Number} y - The Y coordinate.\r\n\t * @param {Number} z - The Z coordinate.\r\n\t * @return {Spherical} This spherical system.\r\n\t */\r\n\r\n\tsetFromCartesianCoords(x, y, z) {\r\n\r\n\t\tthis.radius = Math.sqrt(x * x + y * y + z * z);\r\n\r\n\t\tif(this.radius === 0) {\r\n\r\n\t\t\tthis.theta = 0;\r\n\t\t\tthis.phi = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Calculate the equator angle around the positive Y-axis.\r\n\t\t\tthis.theta = Math.atan2(x, z);\r\n\r\n\t\t\t// Calculate the polar angle.\r\n\t\t\tthis.phi = Math.acos(Math.min(Math.max(y / this.radius, -1), 1));\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A symmetric 3x3 matrix.\r\n */\r\n\r\nclass SymmetricMatrix3 {\r\n\r\n\t/**\r\n\t * Constructs a new symmetric matrix.\r\n\t */\r\n\r\n\tconstructor() {\r\n\r\n\t\t/**\r\n\t\t * The matrix elements.\r\n\t\t *\r\n\t\t * @type {Float32Array}\r\n\t\t */\r\n\r\n\t\tthis.elements = new Float32Array([\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t1, 0,\r\n\t\t\t1\r\n\r\n\t\t]);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this matrix.\r\n\t *\r\n\t * @param {Number} m00 - The value of the first row, first column.\r\n\t * @param {Number} m01 - The value of the first row, second column and the second row, first column.\r\n\t * @param {Number} m02 - The value of the first row, third column and the third row, first column.\r\n\t * @param {Number} m11 - The value of the second row, second column.\r\n\t * @param {Number} m12 - The value of the second row, third column and third row, second column.\r\n\t * @param {Number} m22 - The value of the third row, third column.\r\n\t * @return {SymmetricMatrix3} This matrix.\r\n\t */\r\n\r\n\tset(m00, m01, m02, m11, m12, m22) {\r\n\r\n\t\tconst e = this.elements;\r\n\r\n\t\te[0] = m00;\r\n\t\te[1] = m01; e[3] = m11;\r\n\t\te[2] = m02; e[4] = m12; e[5] = m22;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this matrix to the identity matrix.\r\n\t *\r\n\t * @return {SymmetricMatrix3} This matrix.\r\n\t */\r\n\r\n\tidentity() {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t1, 0,\r\n\t\t\t1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of a given symmetric matrix.\r\n\t *\r\n\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t * @return {SymmetricMatrix3} This matrix.\r\n\t */\r\n\r\n\tcopy(m) {\r\n\r\n\t\tconst me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[0], me[1], me[2],\r\n\t\t\tme[3], me[4],\r\n\t\t\tme[5]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this matrix.\r\n\t *\r\n\t * @return {SymmetricMatrix3} A clone of this matrix.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies this symmetric matrix into a given 3x3 matrix.\r\n\t *\r\n\t * @param {Matrix3} m - The target matrix.\r\n\t */\r\n\r\n\ttoMatrix3(m) {\r\n\r\n\t\tconst me = m.elements;\r\n\r\n\t\tm.set(\r\n\r\n\t\t\tme[0], me[1], me[2],\r\n\t\t\tme[1], me[3], me[4],\r\n\t\t\tme[2], me[4], me[5]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds the values of a given symmetric matrix to this one.\r\n\t *\r\n\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t * @return {SymmetricMatrix3} This matrix.\r\n\t */\r\n\r\n\tadd(m) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tte[0] += me[0];\r\n\t\tte[1] += me[1]; te[3] += me[3];\r\n\t\tte[2] += me[2]; te[4] += me[4]; te[5] += me[5];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the Frobenius norm of this matrix.\r\n\t *\r\n\t * @return {Number} The norm of this matrix.\r\n\t */\r\n\r\n\tnorm() {\r\n\r\n\t\tconst e = this.elements;\r\n\r\n\t\tconst m01m01 = e[1] * e[1];\r\n\t\tconst m02m02 = e[2] * e[2];\r\n\t\tconst m12m12 = e[4] * e[4];\r\n\r\n\t\treturn Math.sqrt(\r\n\r\n\t\t\te[0] * e[0] + m01m01 + m02m02 +\r\n\t\t\tm01m01 + e[3] * e[3] + m12m12 +\r\n\t\t\tm02m02 + m12m12 + e[5] * e[5]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the absolute sum of all matrix components except for the main\r\n\t * diagonal.\r\n\t *\r\n\t * @return {Number} The offset of this matrix.\r\n\t */\r\n\r\n\toff() {\r\n\r\n\t\tconst e = this.elements;\r\n\r\n\t\treturn Math.sqrt(2 * (\r\n\r\n\t\t\t// Diagonal = [0, 3, 5].\r\n\t\t\te[1] * e[1] + e[2] * e[2] + e[4] * e[4]\r\n\r\n\t\t));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies this symmetric matrix to a vector.\r\n\t *\r\n\t * @param {Vector3} v - The vector to modify.\r\n\t * @return {Vector3} The modified vector.\r\n\t */\r\n\r\n\tapplyToVector3(v) {\r\n\r\n\t\tconst x = v.x, y = v.y, z = v.z;\r\n\t\tconst e = this.elements;\r\n\r\n\t\tv.x = e[0] * x + e[1] * y + e[2] * z;\r\n\t\tv.y = e[1] * x + e[3] * y + e[4] * z;\r\n\t\tv.z = e[2] * x + e[4] * y + e[5] * z;\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this matrix equals the given one.\r\n\t *\r\n\t * @param {SymmetricMatrix3} m - A matrix.\r\n\t * @return {Boolean} Whether the matrices are equal.\r\n\t */\r\n\r\n\tequals(m) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tlet result = true;\r\n\t\tlet i;\r\n\r\n\t\tfor(i = 0; result && i < 6; ++i) {\r\n\r\n\t\t\tif(te[i] !== me[i]) {\r\n\r\n\t\t\t\tresult = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the linear index of an element from this matrix.\r\n\t *\r\n\t * Let N be the dimension of the symmetric matrix:\r\n\t *\r\n\t *     index = N * (N - 1) / 2 - (N - i) * (N - i - 1) / 2 + j\r\n\t *\r\n\t * @param {Number} i - The row.\r\n\t * @param {Number} j - The column.\r\n\t * @return {Number} The index into the elements of this matrix.\r\n\t */\r\n\r\n\tstatic calculateIndex(i, j) {\r\n\r\n\t\treturn (3 - (3 - i) * (2 - i) / 2 + j);\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * A vector with four components.\r\n */\r\n\r\nclass Vector4 {\r\n\r\n\t/**\r\n\t * Constructs a new vector.\r\n\t *\r\n\t * @param {Number} [x=0] - The X component.\r\n\t * @param {Number} [y=0] - The Y component.\r\n\t * @param {Number} [z=0] - The Z component.\r\n\t * @param {Number} [w=0] - The W component.\r\n\t */\r\n\r\n\tconstructor(x = 0, y = 0, z = 0, w = 0) {\r\n\r\n\t\t/**\r\n\t\t * The X component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\t/**\r\n\t\t * The Y component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\t/**\r\n\t\t * The Z component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\t/**\r\n\t\t * The W component.\r\n\t\t *\r\n\t\t * @type {Number}\r\n\t\t */\r\n\r\n\t\tthis.w = w;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the values of this vector\r\n\t *\r\n\t * @param {Number} x - The X component.\r\n\t * @param {Number} y - The Y component.\r\n\t * @param {Number} z - The Z component.\r\n\t * @param {Number} w - The W component.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tset(x, y, z, w) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Randomizes the values of this vector\r\n\t *\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\trandom() {\r\n\r\n\t\tthis.x = Math.random();\r\n\t\tthis.y = Math.random();\r\n\t\tthis.z = Math.random();\r\n\t\tthis.w = Math.random();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the values of another vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tcopy(v) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this vector.\r\n\t *\r\n\t * @return {Vector4} A clone of this vector.\r\n\t */\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Copies values from an array.\r\n\t *\r\n\t * @param {Number[]} array - An array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tfromArray(array, offset = 0) {\r\n\r\n\t\tthis.x = array[offset];\r\n\t\tthis.y = array[offset + 1];\r\n\t\tthis.z = array[offset + 2];\r\n\t\tthis.w = array[offset + 3];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores this vector in an array.\r\n\t *\r\n\t * @param {Array} [array] - A target array.\r\n\t * @param {Number} offset - An offset.\r\n\t * @return {Number[]} The array.\r\n\t */\r\n\r\n\ttoArray(array = [], offset = 0) {\r\n\r\n\t\tarray[offset] = this.x;\r\n\t\tarray[offset + 1] = this.y;\r\n\t\tarray[offset + 2] = this.z;\r\n\t\tarray[offset + 3] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores the axis angle from the given quaternion in this vector.\r\n\t *\r\n\t * For more details see:\r\n\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t *\r\n\t * @param {Quaternion} q - A quaternion. Assumed to be normalized\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tsetAxisAngleFromQuaternion(q) {\r\n\r\n\t\tthis.w = 2 * Math.acos(q.w);\r\n\r\n\t\tconst s = Math.sqrt(1 - q.w * q.w);\r\n\r\n\t\tif(s < 1e-4) {\r\n\r\n\t\t\tthis.x = 1;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = q.x / s;\r\n\t\t\tthis.y = q.y / s;\r\n\t\t\tthis.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Stores the axis angle from the given rotation matrix in this vector.\r\n\t *\r\n\t * For more details see:\r\n\t *  http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t *\r\n\t * @param {Matrix4} m - A matrix. The upper 3x3 must be a pure rotation matrix (i.e. unscaled).\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tsetAxisAngleFromRotationMatrix(m) {\r\n\r\n\t\t// Margin to allow for rounding errors.\r\n\t\tconst E = 0.01;\r\n\r\n\t\t// Margin to distinguish between 0 and 180 degrees.\r\n\t\tconst H = 0.1;\r\n\r\n\t\tconst me = m.elements;\r\n\t\tconst m00 = me[0], m01 = me[4], m02 = me[8];\r\n\t\tconst m10 = me[1], m11 = me[5], m12 = me[9];\r\n\t\tconst m20 = me[2], m21 = me[6], m22 = me[10];\r\n\r\n\t\tlet angle;\r\n\t\tlet x, y, z;\r\n\t\tlet xx, yy, zz;\r\n\t\tlet xy, xz, yz;\r\n\t\tlet s;\r\n\r\n\t\tif((Math.abs(m01 - m10) < E) && (Math.abs(m02 - m20) < E) && (Math.abs(m12 - m21) < E)) {\r\n\r\n\t\t\t/* Singularity found. First, check for identity matrix which must have +1\r\n\t\t\tfor all terms in the leading diagonal and zero in other terms. */\r\n\t\t\tif((Math.abs(m01 + m10) < H) && (Math.abs(m02 + m20) < H) && (Math.abs(m12 + m21) < H) && (Math.abs(m00 + m11 + m22 - 3) < H)) {\r\n\r\n\t\t\t\t// This singularity is the identity matrix. The angle is zero.\r\n\t\t\t\tthis.set(1, 0, 0, 0);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// The angle is 180.\r\n\t\t\t\tangle = Math.PI;\r\n\r\n\t\t\t\txx = (m00 + 1) / 2;\r\n\t\t\t\tyy = (m11 + 1) / 2;\r\n\t\t\t\tzz = (m22 + 1) / 2;\r\n\t\t\t\txy = (m01 + m10) / 4;\r\n\t\t\t\txz = (m02 + m20) / 4;\r\n\t\t\t\tyz = (m12 + m21) / 4;\r\n\r\n\t\t\t\tif((xx > yy) && (xx > zz)) {\r\n\r\n\t\t\t\t\t// m00 is the largest diagonal term.\r\n\t\t\t\t\tif(xx < E) {\r\n\r\n\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tx = Math.sqrt(xx);\r\n\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if(yy > zz) {\r\n\r\n\t\t\t\t\t// m11 is the largest diagonal term.\r\n\t\t\t\t\tif(yy < E) {\r\n\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ty = Math.sqrt(yy);\r\n\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// m22 is the largest diagonal term.\r\n\t\t\t\t\tif(zz < E) {\r\n\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tz = Math.sqrt(zz);\r\n\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.set(x, y, z, angle);\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// There are no singularities.\r\n\t\t\ts = Math.sqrt(\r\n\t\t\t\t(m21 - m12) * (m21 - m12) +\r\n\t\t\t\t(m02 - m20) * (m02 - m20) +\r\n\t\t\t\t(m10 - m01) * (m10 - m01)\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent division by zero.\r\n\t\t\tif(Math.abs(s) < 0.001) {\r\n\r\n\t\t\t\ts = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.x = (m21 - m12) / s;\r\n\t\t\tthis.y = (m02 - m20) / s;\r\n\t\t\tthis.z = (m10 - m01) / s;\r\n\t\t\tthis.w = Math.acos((m00 + m11 + m22 - 1) / 2);\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a vector to this one.\r\n\t *\r\n\t * @param {Vector4} v - The vector to add.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tadd(v) {\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a scalar to this vector.\r\n\t *\r\n\t * @param {Number} s - The scalar to add.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\taddScalar(s) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the sum of two given vectors.\r\n\t *\r\n\t * @param {Vector4} a - A vector.\r\n\t * @param {Vector4} b - Another vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\taddVectors(a, b) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a scaled vector to this one.\r\n\t *\r\n\t * @param {Vector4} v - The vector to scale and add.\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\taddScaledVector(v, s) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\t\tthis.w += v.w * s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts a vector from this vector.\r\n\t *\r\n\t * @param {Vector4} v - The vector to subtract.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tsub(v) {\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts a scalar from this vector.\r\n\t *\r\n\t * @param {Number} s - The scalar to subtract.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tsubScalar(s) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the difference between two given vectors.\r\n\t *\r\n\t * @param {Vector4} a - A vector.\r\n\t * @param {Vector4} b - A second vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tsubVectors(a, b) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this vector with another vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tmultiply(v) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\t\tthis.w *= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Multiplies this vector with a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tmultiplyScalar(s) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\t\tthis.z *= s;\r\n\t\tthis.w *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the product of two given vectors.\r\n\t *\r\n\t * @param {Vector4} a - A vector.\r\n\t * @param {Vector4} b - Another vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tmultiplyVectors(a, b) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\t\tthis.w = a.w * b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Divides this vector by another vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tdivide(v) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\t\tthis.w /= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Divides this vector by a given scalar.\r\n\t *\r\n\t * @param {Number} s - A scalar.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tdivideScalar(s) {\r\n\r\n\t\tthis.x /= s;\r\n\t\tthis.y /= s;\r\n\t\tthis.z /= s;\r\n\t\tthis.w /= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a matrix to this vector.\r\n\t *\r\n\t * @param {Matrix4} m - A matrix.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tapplyMatrix4(m) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\r\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Negates this vector.\r\n\t *\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tnegate() {\r\n\r\n\t\tthis.x = -this.x;\r\n\t\tthis.y = -this.y;\r\n\t\tthis.z = -this.z;\r\n\t\tthis.w = -this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the dot product with another vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Number} The dot product.\r\n\t */\r\n\r\n\tdot(v) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the Manhattan length of this vector.\r\n\t *\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tmanhattanLength() {\r\n\r\n\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared length of this vector.\r\n\t *\r\n\t * @return {Number} The squared length.\r\n\t */\r\n\r\n\tlengthSquared() {\r\n\r\n\t\treturn (\r\n\t\t\tthis.x * this.x +\r\n\t\t\tthis.y * this.y +\r\n\t\t\tthis.z * this.z +\r\n\t\t\tthis.w * this.w\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the length of this vector.\r\n\t *\r\n\t * @return {Number} The length.\r\n\t */\r\n\r\n\tlength() {\r\n\r\n\t\treturn Math.sqrt(\r\n\t\t\tthis.x * this.x +\r\n\t\t\tthis.y * this.y +\r\n\t\t\tthis.z * this.z +\r\n\t\t\tthis.w * this.w\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the Manhattan distance to a given vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tmanhattanDistanceTo(v) {\r\n\r\n\t\treturn (\r\n\t\t\tMath.abs(this.x - v.x) +\r\n\t\t\tMath.abs(this.y - v.y) +\r\n\t\t\tMath.abs(this.z - v.z) +\r\n\t\t\tMath.abs(this.w - v.w)\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the squared distance to a given vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Number} The squared distance.\r\n\t */\r\n\r\n\tdistanceToSquared(v) {\r\n\r\n\t\tconst dx = this.x - v.x;\r\n\t\tconst dy = this.y - v.y;\r\n\t\tconst dz = this.z - v.z;\r\n\t\tconst dw = this.w - v.w;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz + dw * dw;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance to a given vector.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Number} The distance.\r\n\t */\r\n\r\n\tdistanceTo(v) {\r\n\r\n\t\treturn Math.sqrt(this.distanceToSquared(v));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes this vector.\r\n\t *\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tnormalize() {\r\n\r\n\t\treturn this.divideScalar(this.length());\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the length of this vector.\r\n\t *\r\n\t * @param {Number} length - The new length.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tsetLength(length) {\r\n\r\n\t\treturn this.normalize().multiplyScalar(length);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adopts the min value for each component of this vector and the given one.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tmin(v) {\r\n\r\n\t\tthis.x = Math.min(this.x, v.x);\r\n\t\tthis.y = Math.min(this.y, v.y);\r\n\t\tthis.z = Math.min(this.z, v.z);\r\n\t\tthis.w = Math.min(this.w, v.w);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adopts the max value for each component of this vector and the given one.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tmax(v) {\r\n\r\n\t\tthis.x = Math.max(this.x, v.x);\r\n\t\tthis.y = Math.max(this.y, v.y);\r\n\t\tthis.z = Math.max(this.z, v.z);\r\n\t\tthis.w = Math.max(this.w, v.w);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clamps this vector.\r\n\t *\r\n\t * @param {Vector4} min - The lower bounds. Assumed to be smaller than max.\r\n\t * @param {Vector4} max - The upper bounds. Assumed to be greater than min.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tclamp(min, max) {\r\n\r\n\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\r\n\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\r\n\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\r\n\t\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Floors this vector.\r\n\t *\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tfloor() {\r\n\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\tthis.z = Math.floor(this.z);\r\n\t\tthis.w = Math.floor(this.w);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Ceils this vector.\r\n\t *\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tceil() {\r\n\r\n\t\tthis.x = Math.ceil(this.x);\r\n\t\tthis.y = Math.ceil(this.y);\r\n\t\tthis.z = Math.ceil(this.z);\r\n\t\tthis.w = Math.ceil(this.w);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rounds this vector.\r\n\t *\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tround() {\r\n\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\tthis.z = Math.round(this.z);\r\n\t\tthis.w = Math.round(this.w);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Lerps towards the given vector.\r\n\t *\r\n\t * @param {Vector4} v - The target vector.\r\n\t * @param {Number} alpha - The lerp factor.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tlerp(v, alpha) {\r\n\r\n\t\tthis.x += (v.x - this.x) * alpha;\r\n\t\tthis.y += (v.y - this.y) * alpha;\r\n\t\tthis.z += (v.z - this.z) * alpha;\r\n\t\tthis.w += (v.w - this.w) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this vector to the lerp result of the given vectors.\r\n\t *\r\n\t * @param {Vector4} v1 - A base vector.\r\n\t * @param {Vector4} v2 - The target vector.\r\n\t * @param {Number} alpha - The lerp factor.\r\n\t * @return {Vector4} This vector.\r\n\t */\r\n\r\n\tlerpVectors(v1, v2, alpha) {\r\n\r\n\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this vector equals the given one.\r\n\t *\r\n\t * @param {Vector4} v - A vector.\r\n\t * @return {Boolean} Whether this vector equals the given one.\r\n\t */\r\n\r\n\tequals(v) {\r\n\r\n\t\treturn (v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w);\r\n\r\n\t}\r\n\r\n}\n\nexport { Box2, Box3, Cylindrical, Euler, Frustum, Line3, Matrix3, Matrix4, Plane, Quaternion, Ray, RotationOrder, Sphere, Spherical, SymmetricMatrix3, Vector2, Vector3, Vector4 };\n","import { Vector3 } from 'math-ds'\nimport * as SparkUtility from './SparkUtility.js'\nconst Diagnostics = require('Diagnostics'); \n\n// Based on this, I do position updates and calculate my angle of rotations\nexport const DIRECTION = {\n    UP: 0, \n    DOWN: 1\n}\n\nexport class Agent {\n    constructor(object, tesseracts, planes) {\n        // Main object\n        this.sceneObject = object; \n        this.sceneObject.hidden = false; \n\n        // Store all tesseracts / planes. \n        // I could need them at any point of time. \n        this.tesseracts = tesseracts; \n        this.planes = planes; \n\n        // Current position. \n        this.position = SparkUtility.getLastPosition(object); \n        this.idx = this.sceneObject.name.split('_')[1]; \n        \n        // Calculate target\n        this.target = this.planes[this.idx].getPosition(); \n\n        // Current direction (fetch from Tesseract because that's where we start)\n        this.curDirection = this.tesseracts[this.idx].getDirection(); \n\n        // Up and down velocities. \n        this.upVel = this.idx % 2 === 0 ? new Vector3(0, 0, -0.0025) : new Vector3(0, 0, -0.0015); \n        this.downVel = this.idx % 2 === 0 ? new Vector3(0, 0, 0.0025) : new Vector3(0, 0, 0.0015); \n        \n        this.diff = new Vector3(0, 0, 0); \n    }\n\n    update() {\n        // Just move from initial position to final target. \n        this.seek(); \n        this.syncPosition(); \n    }\n\n    seek() {\n        if (this.curDirection === DIRECTION.UP) {\n            this.position.add(this.upVel); \n        } else {\n            this.position.add(this.downVel); \n        }\n\n        this.diff.subVectors(this.position, this.target); \n        if (this.diff.length() < 0.01) {\n            this.resetRunner(); \n        }\n    }\n\n    syncPosition() {\n        SparkUtility.syncSceneObject(this.sceneObject, this.position);\n    }\n\n    resetRunner() {\n        let length = this.tesseracts.length; \n        // Find a new random index, anything except the current index. \n        let randIdx = SparkUtility.random(0, length-1); \n        while (randIdx === this.idx) {\n            randIdx = SparkUtility.random(0, length-1); \n        }\n\n        // Choose the tesseract or plane as the starting position\n        let t = this.tesseracts[randIdx];\n        let p = this.planes[randIdx]; \n        let d = SparkUtility.random(0, 1); ; // 0 or 1 \n        // Choose tesseract. \n        if (d === 0) {\n            this.position = t.getPosition(); \n            this.target = p.getPosition(); \n            this.curDirection = t.getDirection(); \n        } else {\n            this.position = p.getPosition();\n            this.target = t.getPosition();\n            this.curDirection = p.getDirection(); \n        }\n\n        // Set the rotation of the agent. \n        if (this.curDirection === DIRECTION.UP) {\n            this.sceneObject.transform.rotationY = 0; \n        } else {\n            this.sceneObject.transform.rotationY = Math.PI; \n        }\n    }\n}","import * as SparkUtility from './SparkUtility'\nimport { DIRECTION } from './Agent'\n\nexport class Plane {\n    constructor(object) {\n        this.position = SparkUtility.getLastPosition(object); \n        this.idx =  object.name.split('_')[1]; \n        // Note: Direction of plane is opposite of tesseract.\n        this.direction = this.idx % 2 === 0 ? DIRECTION.UP : DIRECTION.DOWN; \n    }\n\n    getPosition() {\n        return this.position.clone();\n    }\n\n    getDirection() {\n        return this.direction; \n    }\n}","import { Vector3 } from 'math-ds'\nconst Patches = require('Patches');\nconst Reactive = require('Reactive'); \n\nconst getLastPosition = (sceneObject) => {\n    // Acquire current agent position. \n    let posX = sceneObject.transform.x.pinLastValue(); \n    let posY = sceneObject.transform.y.pinLastValue(); \n    let posZ = sceneObject.transform.z.pinLastValue(); \n    return new Vector3(posX, posY, posZ);\n}\n\nconst syncSceneObject = (sceneObject, targetVector) => {\n    sceneObject.transform.x = targetVector.x; \n    sceneObject.transform.y = targetVector.y;\n    sceneObject.transform.z = targetVector.z; \n}\n\nconst syncSceneObjectWorld = (sceneObject, targetVector) => {\n    sceneObject.worldTransform.x = targetVector.x;\n    sceneObject.worldTransform.y = targetVector.y;\n    sceneObject.worldTransform.z = targetVector.z;  \n}\n\nconst random = (min, max, isDecimal = false) => {\n    if (isDecimal) {\n        return (Math.random() * (max - min) + min).toFixed(3);\n    } else {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n}\n\nexport {\n    getLastPosition,\n    syncSceneObject,\n    syncSceneObjectWorld,\n    random\n}","import * as SparkUtility from './SparkUtility'\nconst Diagnostics = require('Diagnostics'); \nimport { DIRECTION } from './Agent'\n\nexport class Tesseract {\n    constructor(object) {\n        this.sceneObject = object; \n        this.position = SparkUtility.getLastPosition(object); \n        this.idx =  object.name.split('_')[1]; \n        // Note: Direction for tesseract. \n        this.direction = this.idx % 2 === 0 ? DIRECTION.DOWN : DIRECTION.UP; \n\n        this.startAngle = 0; \n        this.factor = Math.random(1)/500; \n    }\n\n    update() {\n        this.startAngle += this.factor; \n        // this.sceneObject.transform.rotationX = this.startAngle;\n        // this.sceneObject.transform.rotationY = this.startAngle; \n        // this.sceneObject.transform.rotationZ = this.startAngle; \n    }\n\n    getDirection() {\n        return this.direction; \n    }\n\n    getPosition() {\n        return this.position.clone(); \n    }\n}","import { Tesseract } from './Tesseract.js'\nimport { Plane } from './Plane.js'\nimport { Agent } from './Agent.js'\n\nconst Diagnostics = require('Diagnostics');\n\nexport class World {\n    constructor(sceneObjects) {\n        // Prepare tesseracts. \n        this.tesseracts = []; \n        this.setupTesseracts(sceneObjects); \n\n        // Prepare planes. \n        this.planes = [];\n        this.setupPlanes(sceneObjects); \n\n        // Prepare agents. \n        this.agents = []; \n        this.setupAgents(sceneObjects);\n    }\n\n    update(snapshot) {\n        this.agents.forEach(a => { \n            a.update(); \n        }); \n\n        this.tesseracts.forEach(t => {\n            t.update(); \n        });\n    }\n\n    setupTesseracts(sceneObjects) {\n        this.objs = sceneObjects['tesseracts'];\n        this.objs.forEach(o => {\n            let t = new Tesseract(o); \n            this.tesseracts.push(t); \n        }); \n    }\n\n    setupPlanes(sceneObjects) {\n        this.objs = sceneObjects['planes']; \n        this.objs.forEach(o => {\n            let p = new Plane(o);\n            this.planes.push(p); \n        }); \n    }\n\n    setupAgents(sceneObjects) {\n        this.objs = sceneObjects['runners']; \n        this.objs.forEach(o => {\n            let a = new Agent(o, this.tesseracts, this.planes); \n            this.agents.push(a); \n        }); \n    }\n}","// main.js\n// Entry level file that sets up all the objects. \nconst Scene = require('Scene');\nconst Diagnostics = require('Diagnostics');\nconst Time = require('Time'); \n\nimport { World } from './World.js'\n\nvar world;\n// Use a wild card (*) to read the entire tree. \n// Array Hierarchy = Scene Viewer Hierarchy\nPromise.all([\n    Scene.root.findByPath('planeTracker/placer/Planes/*'),\n    Scene.root.findByPath('planeTracker/placer/Tesseracts/*'),\n    Scene.root.findByPath('planeTracker/placer/Runners/*'),\n]).then(objects => {\n    let sceneObjects = prepareSceneObjects(objects); \n\n    // Setup agents, octree, etc. \n    world = new World(sceneObjects); \n\n    Diagnostics.log('Setup complete -> Begin Update loop.'); \n\n    //Setup an update loop here. \n    const timeInterval = 15;\n    Time.setIntervalWithSnapshot({\n        // 'lastTargetX' : sceneObjects['camTarget'].transform.x,\n        // 'lastTargetY' : sceneObjects['camTarget'].transform.y,\n        // 'lastTargetZ' : sceneObjects['camTarget'].transform.z,\n    }, (elapsedTime, snapshot) => {\n        world.update(snapshot); \n    }, timeInterval);\n});\n\nfunction prepareSceneObjects(objects) {\n    const a = {\n        'planes' : objects[0],\n        'tesseracts' : objects[1],\n        'runners' : objects[2]\n    }\n    return a; \n}","module.exports = require(\"Diagnostics\");","module.exports = require(\"Patches\");","module.exports = require(\"Reactive\");","module.exports = require(\"Scene\");","module.exports = require(\"Time\");"],"sourceRoot":""}